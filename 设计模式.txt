
设计模式只是一种思想，只要满足这种思想就可以，不要拘泥代码！！！ 但还是要背诵一些基础的代码

软件设计模式
---------------------------
是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结

设计模式的目的
---------------------------
设计模式是为了让程序(软件)，具有更好
1) 代码重用性 (即：相同功能的代码，不用多次编写)
2) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)
3) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护
4) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)
5) 使程序呈现高内聚，低耦合的特性

设计模式常用的七大原则有
---------------------------
1) 单一职责原则
	一个类应该只负责一项职责
2) 接口隔离原则
	一个类对另一个类的依赖应该建立在最小的接口上
3) 依赖倒转原则
	功能写在被依赖的类的方法中
	使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，
4) 里氏替换原则
	在子类中尽量不要重写父类的方法
	所有引用基类的方法必须透明地使用其他子类的对象
5) 开闭原则 ocp
	对扩展开放(提供方)，对修改关闭(使用方)
6) 迪米特法则（最少知道原则）
	对自己依赖的类知道的越少越好
	应该避免类中出现这样非直接朋友关系的耦合
	直接朋友 两个对象之间有耦合关系，就说对象之间是朋友关系
	耦合的方式很多，依赖，关联，组合，聚合等。
	我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友
	而出现在局部变量中的类不是直接的朋友
7) 合成复用原则
	原则是尽量使用合成／聚合的方式，而不是使用继承
	
在记录
---------------------------
	依赖： 对象构造方法中传入
	聚合： set方法传入
	组合： new生成

依赖关系
---------------------------
1.类中使用到对方
2.如果是类的成员属性
3.如果是方法的返回类型
4.是方法接收的参数类型
5.方法中使用到

泛化关系
---------------------------
1.泛化关系实际就是继承关系
2.如果A类继承了B类，我们就说A和B存在泛化关系

结构型模式
---------------------------
站在类的角度思考问题

行为型模式
---------------------------
站在方法的角度思考问题

关键字 volatile 对象立即更新到主存

MUL中的关系表示
---------------------------

表示依赖（Dependency）
---------------------------
虚线+大括号（--->）

表示关联（Association）
---------------------------
实线（——）

表示泛化（继承）(Generalization)
---------------------------
实线+空心三角（——▷）

表示实现（Realization）
---------------------------
虚线+空心三角（---▷）

表示聚合（Aggregation）
---------------------------
棱形
实线+空心棱形（——(●'◡'●)）

表示组合（Composite）依赖的一定是实例（非空，必须要有）
---------------------------
实线+实心棱形（——实心正方形压瘪(●'◡'●)）

设计模式类型
---------------------------
1）创建型模式：单例模式、工厂模式、抽象工厂模式、原型模式、建造者模式。
2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
3）行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、
   解释器模式 (Interpreter 模式）、状态模式、策略模式、职责链模式（责任链模式）。
   
单例模式
---------------------------
1) 饿汉式（静态常量）
2) 饿汉式（静态代码块）
3) 懒汉式（线程不安全）
4) 懒汉式（线程安全，同步方法）
5) 懒汉式（线程安全，同步代码块）
6) 双重检查
7) 静态内部类
8) 枚举

1) 饿汉式（静态常量）
---------------------------
//饿汉式(静态变量)
class Singleton {
	
	//1. 构造器私有化, 外部能new
	private Singleton() {
		
	}
	
	//2.本类内部创建对象实例
	private final static Singleton instance = new Singleton();
	
	//3. 提供一个公有的静态方法，返回实例对象
	public static Singleton getInstance() {
		return instance;
	}
	
}

2) 饿汉式（静态代码块）
---------------------------
class Singleton {
	
	//1. 构造器私有化, 外部能new
	private Singleton() {
		
	}
	
	//2.本类内部创建对象实例
	private  static Singleton instance;
	
	static { // 在静态代码块中，创建单例对象
		instance = new Singleton();
	}
	
	//3. 提供一个公有的静态方法，返回实例对象
	public static Singleton getInstance() {
		return instance;
	}
}

3) 懒汉式（线程不安全）
---------------------------
class Singleton {
	private static Singleton instance;
	
	private Singleton() {}
	
	//提供一个静态的公有方法，当使用到该方法时，才去创建 instance
	//即懒汉式
	public static Singleton getInstance() {
		if(instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}

4) 懒汉式（线程安全，同步方法）
---------------------------
效率底，不推荐
class Singleton {
	private static Singleton instance;
	
	private Singleton() {}
	
	//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题
	//即懒汉式
	public static synchronized Singleton getInstance() {
		if(instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}

5) 懒汉式（线程安全，同步代码块）
---------------------------
class Singleton{
    private static Singleton instance;

    private Singleton() {
    }
	//新手常这么写，这里的线程是不安全的
    public static Singleton getInstance() {
        if(instance == null){
            synchronized (Singleton.class){
                instance = new Singleton();
            }
        }
        return instance;
    }
}

6) 双重检查（推荐使用）
---------------------------
// 懒汉式(线程安全，双重检查 同步方法)
class Singleton {
	private static volatile Singleton instance;
	
	private Singleton() {}
	
	//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题
	//同时保证了效率, 推荐使用
	
	public static synchronized Singleton getInstance() {
		if(instance == null) {
			synchronized (Singleton.class) {
				if(instance == null) {
					instance = new Singleton();
				}
			}
			
		}
		return instance;
	}
}


7) 静态内部类
---------------------------
// 静态内部类完成， 推荐使用
class Singleton {
	
	//构造器私有化
	private Singleton() {}
	
	//写一个静态内部类,该类中有一个静态属性 Singleton
	private static class SingletonInstance {
		private static final Singleton INSTANCE = new Singleton(); 
	}
	
	//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
	
	public static  Singleton getInstance() {
		
		return SingletonInstance.INSTANCE;
	}
}

这种方式采用了类装载的机制来保证初始化实例时只有一个线程
静态内部类方式在被装载时并不会立即实例化，而是在需要实例化



8) 枚举
---------------------------
这借助 JDK 巧中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建
public class SingletonTest08 {
	public static void main(String[] args) {
		Singleton instance = Singleton.INSTANCE;
		// 这里直接调用方法，跳跳道路通罗马呀
		instance.sayOK();
	}
}

//使用枚举，可以实现单例, 推荐
enum Singleton {
	INSTANCE; //属性
	public void sayOK() {
		System.out.println("ok~");
	}
}

工厂模式（至少能说出来）
---------------------------
在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式，
1.简单工厂模式（也叫 静态工厂模式 ）
2.工厂方法模式
3.抽象工厂模式


1.简单工厂模式（也叫 静态工厂模式 ）
---------------------------
点不同口味的
//简单工厂类
public class SimpleFactory {

	//更加orderType 返回对应的Pizza 对象
	public Pizza createPizza(String orderType) {

		Pizza pizza = null;

		System.out.println("使用简单工厂模式");
		if (orderType.equals("greek")) {
			pizza = new GreekPizza();
			pizza.setName(" 希腊披萨 ");
		} else if (orderType.equals("cheese")) {
			pizza = new CheesePizza();
			pizza.setName(" 奶酪披萨 ");
		} else if (orderType.equals("pepper")) {
			pizza = new PepperPizza();
			pizza.setName("胡椒披萨");
		}
		
		return pizza;
	}
	
	//简单工厂模式 也叫 静态工厂模式 
	
	public static Pizza createPizza2(String orderType) {

		Pizza pizza = null;

		System.out.println("使用简单工厂模式2");
		if (orderType.equals("greek")) {
			pizza = new GreekPizza();
			pizza.setName(" 希腊披萨 ");
		} else if (orderType.equals("cheese")) {
			pizza = new CheesePizza();
			pizza.setName(" 奶酪披萨 ");
		} else if (orderType.equals("pepper")) {
			pizza = new PepperPizza();
			pizza.setName("胡椒披萨");
		}
		
		return pizza;
	}

}

2.工厂方法模式
---------------------------
点不同地方，不同口味的
1) 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。
2)工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类

public abstract class OrderPizza {

	//定义一个抽象方法，createPizza , 让各个工厂子类自己实现
	abstract Pizza createPizza(String orderType);
	
	// 构造器
	public OrderPizza() {
		Pizza pizza = null;
		String orderType; // 订购披萨的类型
		do {
			orderType = getType();
			pizza = createPizza(orderType); //抽象方法，由工厂子类完成 推迟调用方法
			//输出pizza 制作过程
			pizza.prepare();
			pizza.bake();
			pizza.cut();
			pizza.box();
			
		} while (true);
	}

	

	// 写一个方法，可以获取客户希望订购的披萨种类
	private String getType() {
		try {
			BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
			System.out.println("input pizza 种类:");
			String str = strin.readLine();
			return str;
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}

}

public class BJOrderPizza extends OrderPizza {

	
	@Override
	Pizza createPizza(String orderType) {
	
		Pizza pizza = null;
		if(orderType.equals("cheese")) {
			pizza = new BJCheesePizza();
		} else if (orderType.equals("pepper")) {
			pizza = new BJPepperPizza();
		}
		// TODO Auto-generated method stub
		return pizza;
	}

}


3.抽象工厂模式
---------------------------
将简单工厂模式和工厂方法模式进行整合。

l) 抽象工厂模式：定义了一个用于创建相关或有依赖关系的对象簇，而无需指明具体的类
2）将工厂抽象成两层 AbsFactory( 抽象工厂）和具体实现的工厂子类。
	这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。
	
//一个抽象工厂模式的抽象层(接口)
public interface AbsFactory {
	//让下面的工厂子类来 具体实现
	public Pizza createPizza(String orderType);
}
---------------------------
//这是工厂子类
public class BJFactory implements AbsFactory {

	@Override
	public Pizza createPizza(String orderType) {
		System.out.println("~使用的是抽象工厂模式~");
		// TODO Auto-generated method stub
		Pizza pizza = null;
		if(orderType.equals("cheese")) {
			pizza = new BJCheesePizza();
		} else if (orderType.equals("pepper")){
			pizza = new BJPepperPizza();
		}
		return pizza;
	}

}
---------------------------

public class OrderPizza {

	AbsFactory factory;

	// 构造器
	public OrderPizza(AbsFactory factory) {
		setFactory(factory);
	}

	private void setFactory(AbsFactory factory) {
		Pizza pizza = null;
		String orderType = ""; // 用户输入
		this.factory = factory;
		do {
			orderType = getType();
			// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类
			pizza = factory.createPizza(orderType);
			if (pizza != null) { // 订购ok
				pizza.prepare();
				pizza.bake();
				pizza.cut();
				pizza.box();
			} else {
				System.out.println("订购失败");
				break;
			}
		} while (true);
	}

	// 写一个方法，可以获取客户希望订购的披萨种类
	private String getType() {
		try {
			BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
			System.out.println("input pizza 种类:");
			String str = strin.readLine();
			return str;
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}
}

原型模式
---------------------------
用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象

1) Prototype ，原型类，声明一个克隆自己的接口
2) ConcretePrototype: 具体的原型类，实现一个克隆自己的操作
3) Client: 让一个原型对象克隆自己，从而创建一个新的对象（属性一样）

浅拷贝克隆，某个数组，某个对象只拷贝
---------------------------
public class Sheep implements Cloneable {

	// 部分代码省略
	//克隆该实例，使用默认的clone方法来完成
	@Override
	protected Object clone()  {
		
		Sheep sheep = null;
		try {
			sheep = (Sheep)super.clone();
		} catch (Exception e) {
			// TODO: handle exception
			System.out.println(e.getMessage());
		}
		// TODO Auto-generated method stub
		return sheep;
	}
	
	
}

深拷贝
---------------------------
public class DeepProtoType implements Serializable, Cloneable{
	
	public String name; //String 属性
	public DeepCloneableTarget deepCloneableTarget;// 引用类型
	public DeepProtoType() {
		super();
	}
	
	
	//深拷贝 - 方式 1 使用clone 方法
	@Override
	protected Object clone() throws CloneNotSupportedException {
		
		Object deep = null;
		//这里完成对基本数据类型(属性)和String的克隆
		deep = super.clone(); 
		//对引用类型的属性，进行单独处理
		DeepProtoType deepProtoType = (DeepProtoType)deep;
		deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();
		
		// TODO Auto-generated method stub
		return deepProtoType;
	}
	
	//深拷贝 - 方式2 通过对象的序列化实现 (推荐)
	
	public Object deepClone() {
		
		//创建流对象
		ByteArrayOutputStream bos = null;
		ObjectOutputStream oos = null;
		ByteArrayInputStream bis = null;
		ObjectInputStream ois = null;
		
		try {
			
			//序列化
			bos = new ByteArrayOutputStream();
			oos = new ObjectOutputStream(bos);
			oos.writeObject(this); //当前这个对象以对象流的方式输出
			
			//反序列化
			bis = new ByteArrayInputStream(bos.toByteArray());
			ois = new ObjectInputStream(bis);
			DeepProtoType copyObj = (DeepProtoType)ois.readObject();
			
			return copyObj;
			
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
			return null;
		} finally {
			//关闭流
			try {
				bos.close();
				oos.close();
				bis.close();
				ois.close();
			} catch (Exception e2) {
				// TODO: handle exception
				System.out.println(e2.getMessage());
			}
		}
		
	}
	
}


建造者模式
---------------------------
Builder Pattern叫生成器模式，是一种对象构建模式它可以将复杂对象的建造过程抽象出来


l) Product （产品角色）:一个具体的产品对象。
2) Builder （抽象建造者）：创建一个 Product 对象的各个部件指定的接口啪象类。
3) ConcreteBuilder （具体建造者）：实现接口，构建和装配各个部件。
4) Director （指挥者）：构建一个使用 Builder 接口的对象。
   一是：隔离了客户与对象的生产过程
   二是：负责控制产品对象的生产过程。
   
public class Client {
	public static void main(String[] args) {
		
		//盖普通房子
		CommonHouse commonHouse = new CommonHouse();
		//准备创建房子的指挥者
		HouseDirector houseDirector = new HouseDirector(commonHouse);
		
		//完成盖房子，返回产品(普通房子)
		House house = houseDirector.constructHouse();
		
		//System.out.println("输出流程");
		
		System.out.println("--------------------------");
		//盖高楼
		HighBuilding highBuilding = new HighBuilding();
		//重置建造者
		houseDirector.setHouseBuilder(highBuilding);
		//完成盖房子，返回产品(高楼)
		houseDirector.constructHouse();
	}
}

l) Product （产品角色）:一个具体的产品对象。
---------------------------
public class House {
	private String baise;
	private String wall;
	private String roofed;
	public String getBaise() {
		return baise;
	}
	public void setBaise(String baise) {
		this.baise = baise;
	}
	public String getWall() {
		return wall;
	}
	public void setWall(String wall) {
		this.wall = wall;
	}
	public String getRoofed() {
		return roofed;
	}
	public void setRoofed(String roofed) {
		this.roofed = roofed;
	}
	
}

2) Builder （抽象建造者）：创建一个 Product 对象的各个部件指定的接口啪象类。
---------------------------
// 抽象的建造者
public abstract class HouseBuilder {

	protected House house = new House();
	
	//将建造的流程写好, 抽象的方法
	public abstract void buildBasic();
	public abstract void buildWalls();
	public abstract void roofed();
	
	//建造房子好， 将产品(房子) 返回
	public House buildHouse() {
		return house;
	}
	
}

3) ConcreteBuilder （具体建造者）：实现接口，构建和装配各个部件。
---------------------------
HouseBuilder的实现
public class CommonHouse extends HouseBuilder {

	@Override
	public void buildBasic() {
		// TODO Auto-generated method stub
		System.out.println(" 普通房子打地基5米 ");
	}

	@Override
	public void buildWalls() {
		// TODO Auto-generated method stub
		System.out.println(" 普通房子砌墙10cm ");
	}

	@Override
	public void roofed() {
		// TODO Auto-generated method stub
		System.out.println(" 普通房子屋顶 ");
	}

}

4) Director （指挥者）：构建一个使用 Builder 接口的对象。
   一是：隔离了客户与对象的生产过程
   二是：负责控制产品对象的生产过程。
---------------------------
//指挥者，这里去指定制作流程，返回产品
public class HouseDirector {
	
	HouseBuilder houseBuilder = null;

	//构造器传入 houseBuilder
	public HouseDirector(HouseBuilder houseBuilder) {
		this.houseBuilder = houseBuilder;
	}

	//通过setter 传入 houseBuilder
	public void setHouseBuilder(HouseBuilder houseBuilder) {
		this.houseBuilder = houseBuilder;
	}
	
	//如何处理建造房子的流程，交给指挥者
	public House constructHouse() {
		houseBuilder.buildBasic();
		houseBuilder.buildWalls();
		houseBuilder.roofed();
		return houseBuilder.buildHouse();
	}
	
	
}

---------------------------
结构模式
---------------------------

适配器模式
---------------------------
主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。
其别名为包装器（ Wrapper ）

主要分为三类：类适配器模式、对象适配器模式、接口适配器模式

---------------------------
类适配器
---------------------------

public class Client {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(" === 类适配器模式 ====");
		Phone phone = new Phone();
		phone.charging(new VoltageAdapter());
	}

}

---------------------------
//适配接口
public interface IVoltage5V {
	public int output5V();
}


---------------------------
//被适配的类
public class Voltage220V {
	//输出220V的电压
	public int output220V() {
		int src = 220;
		System.out.println("电压=" + src + "伏");
		return src;
	}
}

---------------------------
//适配器类
public class VoltageAdapter extends Voltage220V implements IVoltage5V {

	@Override
	public int output5V() {
		// TODO Auto-generated method stub
		//获取到220V电压
		int srcV = output220V();
		int dstV = srcV / 44 ; //转成 5v
		return dstV;
	}

}

---------------------------
手机
public class Phone {

	//充电
	public void charging(IVoltage5V iVoltage5V) {
		if(iVoltage5V.output5V() == 5) {
			System.out.println("电压为5V, 可以充电~~");
		} else if (iVoltage5V.output5V() > 5) {
			System.out.println("电压大于5V, 不能充电~~");
		}
	}
}

对象适配器模式
---------------------------
根据“合成复用原则，在系统中尽量使用关联关系（聚合）来替代继承关系。
对象适配器模式是适配器模式常用的一种

public class Client {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println(" === 对象适配器模式 ====");
		Phone phone = new Phone();
		phone.charging(new VoltageAdapter(new Voltage220V()));
	}

}

---------------------------
//适配接口
public interface IVoltage5V {
	public int output5V();
}

---------------------------
//适配器类
public class VoltageAdapter  implements IVoltage5V {

	private Voltage220V voltage220V; // 关联关系-聚合
	
	//通过构造器，传入一个 Voltage220V 实例
	public VoltageAdapter(Voltage220V voltage220v) {
		
		this.voltage220V = voltage220v;
	}

	@Override
	public int output5V() {
		
		int dst = 0;
		if(null != voltage220V) {
			int src = voltage220V.output220V();//获取220V 电压
			System.out.println("使用对象适配器，进行适配~~");
			dst = src / 44;
			System.out.println("适配完成，输出的电压为=" + dst);
		}
		
		return dst;
		
	}

}

---------------------------
//被适配的类
public class Voltage220V {
	//输出220V的电压
	public int output220V() {
		int src = 220;
		System.out.println("电压=" + src + "伏");
		return src;
	}
}

接口适配器模式
---------------------------
1) 一些书籍称为：适配器模式 (Default Adapter pattern ）或缺省适配器模式
2) 核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，
	并为该接口中每个方法提供一个默认实现（空方法），
	那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求

	
public class Client {
	public static void main(String[] args) {
		
		AbsAdapter absAdapter = new AbsAdapter() {
			//只需要去覆盖我们 需要使用 接口方法
			@Override
			public void m1() {
				// TODO Auto-generated method stub
				System.out.println("使用了m1的方法");
			}
		};
		
		absAdapter.m1();
	}
}


---------------------------
public interface Interface4 {
	public void m1();
	public void m2();
	public void m3();
	public void m4();
}

---------------------------
//在AbsAdapter 我们将 Interface4 的方法进行默认实现
public abstract class AbsAdapter implements Interface4 {

	//默认实现
	public void m1() {

	}

	public void m2() {

	}

	public void m3() {

	}

	public void m4() {

	}
}
