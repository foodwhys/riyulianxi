
设计模式只是一种思想，只要满足这种思想就可以，不要拘泥代码！！！ 但还是要背诵一些基础的代码

软件设计模式
---------------------------
是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结

设计模式的目的
---------------------------
设计模式是为了让程序(软件)，具有更好
1) 代码重用性 (即：相同功能的代码，不用多次编写)
2) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)
3) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护
4) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)
5) 使程序呈现高内聚，低耦合的特性

设计模式常用的七大原则有
---------------------------
1) 单一职责原则
	一个类应该只负责一项职责
2) 接口隔离原则
	一个类对另一个类的依赖应该建立在最小的接口上
3) 依赖倒转原则
	功能写在被依赖的类的方法中
	使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，
4) 里氏替换原则
	在子类中尽量不要重写父类的方法
	所有引用基类的方法必须透明地使用其他子类的对象
5) 开闭原则 ocp
	对扩展开放(提供方)，对修改关闭(使用方)
6) 迪米特法则（最少知道原则）
	对自己依赖的类知道的越少越好
	应该避免类中出现这样非直接朋友关系的耦合
	直接朋友 两个对象之间有耦合关系，就说对象之间是朋友关系
	耦合的方式很多，依赖，关联，组合，聚合等。
	我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友
	而出现在局部变量中的类不是直接的朋友
7) 合成复用原则
	原则是尽量使用合成／聚合的方式，而不是使用继承
	
在记录
---------------------------
	依赖： 对象构造方法中传入
	聚合： set方法传入
	组合： new生成

依赖关系
---------------------------
1.类中使用到对方
2.如果是类的成员属性
3.如果是方法的返回类型
4.是方法接收的参数类型
5.方法中使用到

泛化关系
---------------------------
1.泛化关系实际就是继承关系
2.如果A类继承了B类，我们就说A和B存在泛化关系

结构型模式
---------------------------
站在类的角度思考问题

行为型模式
---------------------------
站在方法的角度思考问题

关键字 volatile 对象立即更新到主存

MUL中的关系表示
---------------------------

表示依赖（Dependency）
---------------------------
虚线+大括号（--->）

表示关联（Association）
---------------------------
实线（——）

表示泛化（继承）(Generalization)
---------------------------
实线+空心三角（——▷）

表示实现（Realization）
---------------------------
虚线+空心三角（---▷）

表示聚合（Aggregation）
---------------------------
棱形
实线+空心棱形（——(●'◡'●)）

表示组合（Composite）依赖的一定是实例（非空，必须要有）
---------------------------
实线+实心棱形（——实心正方形压瘪(●'◡'●)）

设计模式类型
---------------------------
1）创建型模式：单例模式、工厂模式、抽象工厂模式、原型模式、建造者模式。
2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
3）行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、
   解释器模式 (Interpreter 模式）、状态模式、策略模式、职责链模式（责任链模式）。
   
单例模式
---------------------------
1) 饿汉式（静态常量）
2) 饿汉式（静态代码块）
3) 懒汉式（线程不安全）
4) 懒汉式（线程安全，同步方法）
5) 懒汉式（线程安全，同步代码块）
6) 双重检查
7) 静态内部类
8) 枚举

1) 饿汉式（静态常量）
---------------------------
//饿汉式(静态变量)
class Singleton {
	
	//1. 构造器私有化, 外部能new
	private Singleton() {
		
	}
	
	//2.本类内部创建对象实例
	private final static Singleton instance = new Singleton();
	
	//3. 提供一个公有的静态方法，返回实例对象
	public static Singleton getInstance() {
		return instance;
	}
	
}

2) 饿汉式（静态代码块）
---------------------------
class Singleton {
	
	//1. 构造器私有化, 外部能new
	private Singleton() {
		
	}
	
	//2.本类内部创建对象实例
	private  static Singleton instance;
	
	static { // 在静态代码块中，创建单例对象
		instance = new Singleton();
	}
	
	//3. 提供一个公有的静态方法，返回实例对象
	public static Singleton getInstance() {
		return instance;
	}
}

3) 懒汉式（线程不安全）
---------------------------
class Singleton {
	private static Singleton instance;
	
	private Singleton() {}
	
	//提供一个静态的公有方法，当使用到该方法时，才去创建 instance
	//即懒汉式
	public static Singleton getInstance() {
		if(instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}

4) 懒汉式（线程安全，同步方法）
---------------------------
效率底，不推荐
class Singleton {
	private static Singleton instance;
	
	private Singleton() {}
	
	//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题
	//即懒汉式
	public static synchronized Singleton getInstance() {
		if(instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}

5) 懒汉式（线程安全，同步代码块）
---------------------------
class Singleton{
    private static Singleton instance;

    private Singleton() {
    }
	//新手常这么写，这里的线程是不安全的
    public static Singleton getInstance() {
        if(instance == null){
            synchronized (Singleton.class){
                instance = new Singleton();
            }
        }
        return instance;
    }
}

6) 双重检查（推荐使用）
---------------------------
// 懒汉式(线程安全，双重检查 同步方法)
class Singleton {
	private static volatile Singleton instance;
	
	private Singleton() {}
	
	//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题
	//同时保证了效率, 推荐使用
	
	public static synchronized Singleton getInstance() {
		if(instance == null) {
			synchronized (Singleton.class) {
				if(instance == null) {
					instance = new Singleton();
				}
			}
			
		}
		return instance;
	}
}


7) 静态内部类
---------------------------
// 静态内部类完成， 推荐使用
class Singleton {
	
	//构造器私有化
	private Singleton() {}
	
	//写一个静态内部类,该类中有一个静态属性 Singleton
	private static class SingletonInstance {
		private static final Singleton INSTANCE = new Singleton(); 
	}
	
	//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
	
	public static  Singleton getInstance() {
		
		return SingletonInstance.INSTANCE;
	}
}

这种方式采用了类装载的机制来保证初始化实例时只有一个线程
静态内部类方式在被装载时并不会立即实例化，而是在需要实例化



8) 枚举
---------------------------
这借助 JDK 巧中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建
public class SingletonTest08 {
	public static void main(String[] args) {
		Singleton instance = Singleton.INSTANCE;
		// 这里直接调用方法，跳跳道路通罗马呀
		instance.sayOK();
	}
}

//使用枚举，可以实现单例, 推荐
enum Singleton {
	INSTANCE; //属性
	public void sayOK() {
		System.out.println("ok~");
	}
}

工厂模式（至少能说出来）
---------------------------
在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式，
1.简单工厂模式（也叫 静态工厂模式 ）
2.工厂方法模式
3.抽象工厂模式


1.简单工厂模式（也叫 静态工厂模式 ）
---------------------------
点不同口味的
//简单工厂类
public class SimpleFactory {

	//更加orderType 返回对应的Pizza 对象
	public Pizza createPizza(String orderType) {

		Pizza pizza = null;

		System.out.println("使用简单工厂模式");
		if (orderType.equals("greek")) {
			pizza = new GreekPizza();
			pizza.setName(" 希腊披萨 ");
		} else if (orderType.equals("cheese")) {
			pizza = new CheesePizza();
			pizza.setName(" 奶酪披萨 ");
		} else if (orderType.equals("pepper")) {
			pizza = new PepperPizza();
			pizza.setName("胡椒披萨");
		}
		
		return pizza;
	}
	
	//简单工厂模式 也叫 静态工厂模式 
	
	public static Pizza createPizza2(String orderType) {

		Pizza pizza = null;

		System.out.println("使用简单工厂模式2");
		if (orderType.equals("greek")) {
			pizza = new GreekPizza();
			pizza.setName(" 希腊披萨 ");
		} else if (orderType.equals("cheese")) {
			pizza = new CheesePizza();
			pizza.setName(" 奶酪披萨 ");
		} else if (orderType.equals("pepper")) {
			pizza = new PepperPizza();
			pizza.setName("胡椒披萨");
		}
		
		return pizza;
	}

}

2.工厂方法模式
---------------------------
点不同地方，不同口味的
1) 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。
2)工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类

public abstract class OrderPizza {

	//定义一个抽象方法，createPizza , 让各个工厂子类自己实现
	abstract Pizza createPizza(String orderType);
	
	// 构造器
	public OrderPizza() {
		Pizza pizza = null;
		String orderType; // 订购披萨的类型
		do {
			orderType = getType();
			pizza = createPizza(orderType); //抽象方法，由工厂子类完成 推迟调用方法
			//输出pizza 制作过程
			pizza.prepare();
			pizza.bake();
			pizza.cut();
			pizza.box();
			
		} while (true);
	}

	

	// 写一个方法，可以获取客户希望订购的披萨种类
	private String getType() {
		try {
			BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
			System.out.println("input pizza 种类:");
			String str = strin.readLine();
			return str;
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}

}

public class BJOrderPizza extends OrderPizza {

	
	@Override
	Pizza createPizza(String orderType) {
	
		Pizza pizza = null;
		if(orderType.equals("cheese")) {
			pizza = new BJCheesePizza();
		} else if (orderType.equals("pepper")) {
			pizza = new BJPepperPizza();
		}
		// TODO Auto-generated method stub
		return pizza;
	}

}


3.抽象工厂模式
---------------------------
将简单工厂模式和工厂方法模式进行整合。

l) 抽象工厂模式：定义了一个用于创建相关或有依赖关系的对象簇，而无需指明具体的类
2）将工厂抽象成两层 AbsFactory( 抽象工厂）和具体实现的工厂子类。
	这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。
	
