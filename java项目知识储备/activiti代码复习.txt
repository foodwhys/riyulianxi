流程部署配置
--------------------------------
 //创建工作流引擎配置
 ProcessEngineConfigurationImpl processEngineConfiguration = 
 (ProcessEngineConfigurationImpl) ProcessEngineConfiguration 
 .createProcessEngineConfigurationFromResource("activiti.cfg.xml"); 
 //创建工作流引擎
 ProcessEngine engine = processEngineConfiguration.buildProcessEngine();

第八章 核心API
--------------------------------

--------------------------------
存储服务API
--------------------------------

部署流程定义
--------------------------------
 //获取流程存储服务
 RepositoryService repositoryService = engine.getRepositoryService();
 //部署流程
 Deployment deployment = repositoryService
 .createDeployment()
 .addClasspathResource("processes/SimpleProcess.bpmn20.xml")
 .deploy();
 
 //查询流程定义
 ProcessDefinition processDefinition = repositoryService
 .createProcessDefinitionQuery() 
 .deploymentId(deployment.getId())
 .singleResult(); 
 
 System.out.println(
 "流程定义ID为：" + processDefinition.getId() + 
 "，流程名称为：" + processDefinition.getName() + 
 "，版本号：" + processDefinition.getVersion());

删除流程定义
--------------------------------
 //删除指定的部署，不进行级联删除
 void deleteDeployment(String deploymentId);
 //可级联删除指定的部署，级联删除包括删除流程实例、job等
 void deleteDeployment(String deploymentId, boolean cascade);
 
 第一个方法只有一个参数deploymentId，
 第二个方法增加了一个cascade参数，用于指定是否进行级联删除
 不管是否指定进行级联删除，流程部署信息、流程定义数据、资源数据等都会被删除。
 如果指定进行级联删除，会同时删除流程对应的运行时流程实例、历史流程实例、关联的job等。
 
挂起流程定义
--------------------------------
 如果暂时不想再使用部署后的流程定义，则可以挂起。
 RepositoryService接口中提供了多种挂起流程定义的方法：
 //根据流程定义ID 立即挂起
 void suspendProcessDefinitionById(String processDefinitionId); 
 //根据流程定义ID在指定日期挂起
 void suspendProcessDefinitionById(String processDefinitionId, boolean suspendProcessInstances, Date suspensionDate); 
 //根据流程定义key立即挂起
 void suspendProcessDefinitionByKey(String processDefinitionKey); 
 //根据流程定义key在指定日期挂起
 void suspendProcessDefinitionByKey(String processDefinitionKey, boolean 
 suspendProcessInstances, Date suspensionDate); 
 //根据流程定义key和租户ID立即挂起
 void suspendProcessDefinitionByKey(String processDefinitionKey, String tenantId); 
 //根据流程定义key和租户ID在指定日期挂起
 void suspendProcessDefinitionByKey(String processDefinitionKey, boolean 
 suspendProcessInstances, Date suspensionDate, String tenantId);

激活流程定义
--------------------------------
 //根据流程定义ID立即激活
 void activateProcessDefinitionById(String processDefinitionId); 
 //根据流程定义ID在指定日期激活
 void activateProcessDefinitionById(String processDefinitionId, 
 boolean activateProcessInstances, Date activationDate); 
 //根据流程定义key立即激活
 void activateProcessDefinitionByKey(String processDefinitionKey); 
 //根据流程定义key在指定日期激活
 void activateProcessDefinitionByKey(String processDefinitionKey, 
 boolean activateProcessInstances, Date activationDate); 
 //根据流程定义key和租户ID立即激活
 void activateProcessDefinitionByKey(String processDefinitionKey, String tenantId); 
 //根据流程定义key和租户ID在指定日期激活
 void activateProcessDefinitionByKey(String processDefinitionKey, 
 boolean activateProcessInstances, Date activationDate, String tenantId);

-------------------------------- 
运行时服务API
--------------------------------

发起流程实例
--------------------------------
 //初始化工作流引擎
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 //部署流程
 ProcessDefinition processDefinition = 
 deployByClasspathResource("processes/SimpleProcess.bpmn20.xml"); 
 System.out.println("流程定义ID为：" + processDefinition.getId() + "，流程定义key为："+ processDefinition.getKey());
 
 //根据流程定义ID发起流程
 ProcessInstance processInstance = runtimeService
 .startProcessInstanceById(processDefinition.getId());
 queryProcessInstance(processInstance.getId()); 
 
 //根据流程定义key发起流程
 ProcessInstance processInstance2 = runtimeService
 .createProcessInstanceBuilder()
 .processDefinitionKey(processDefinition.getKey())
 .name("SimpleProcessInstance")
 .start();
 
唤醒一个等待状态的执行
--------------------------------
 RuntimeService接口提供了
 
 //唤醒等待状态的执行
 void trigger(String executionId); 
 //唤醒等待状态的执行，同时传入新的流程变量
 void trigger(String executionId, Map<String, Object> processVariables); 
 //唤醒等待状态的执行，同时传入新的流程变量和瞬时变量
 void trigger(String executionId, Map<String, Object> processVariables, Map<String, Object> transientVariables);

--------------------------------
任务服务API
--------------------------------

待办任务查询
--------------------------------
TaskService 接口提供了
 //创建任务查询对象
 TaskQuery createTaskQuery(); 
 
 //创建通过SQL直接查询任务的对象
 NativeTaskQuery createNativeTaskQuery();

待办任务查询 示例代码 
-------------------------------- 
 //查询用户待办任务
 List<Task> taskList = taskService
 .createTaskQuery()
 .taskCandidateOrAssigned(userId)
 .orderByTaskCreateTime().desc().list();
 
 if (taskList != null && taskList.size() > 0) { 
 for (Task task : taskList) { 
	System.out.println(
	"任务[" + task.getName() + "]
	(ID=" + task.getId() + ")" + 
	"的办理人为：" + task.getAssignee() + 
	"，创建时间为：" + dateFormat.format(task.getCreateTime()) 
	);
 }
 
任务办理及权限控制
--------------------------------
TaskService接口提供了多种任务办理方法，以及人员与任务关系管理方法
 //任务办理相关设置
 void claim(String taskId, String userId); 
 void unclaim(String taskId); 
 void delegateTask(String taskId, String userId); 
 void resolveTask(String taskId); 
 void resolveTask(String taskId, Map<String, Object> variables); 
 void resolveTask(String taskId, Map<String, Object> variables, 
 Map<String, Object> transientVariables); 
 void complete(String taskId); 
 void complete(String taskId, Map<String, Object> variables); 
 void complete(String taskId, Map<String, Object> variables, 
 Map<String, Object> transientVariables); 
 void complete(String taskId, Map<String, Object> variables, boolean localScope); 
 
 //人员与任务关系管理
 void setAssignee(String taskId, String userId); 
 void setOwner(String taskId, String userId); 
 void addCandidateUser(String taskId, String userId); 
 void addCandidateGroup(String taskId, String groupId); 
 void addUserIdentityLink(String taskId, String userId, String identityLinkType); 
 void addGroupIdentityLink(String taskId, String groupId, String identityLinkType); 
 void deleteCandidateUser(String taskId, String userId); 
 void deleteCandidateGroup(String taskId, String groupId); 
 void deleteUserIdentityLink(String taskId, String userId, String identityLinkType); 
 void deleteGroupIdentityLink(String taskId, String groupId, String identityLinkType); 
 List<IdentityLink> getIdentityLinksForTask(String taskId);
 
示例代码 
--------------------------------
 //设置任务与人员的关系
 taskService.addCandidateUser(secondTask.getId(), "hebo");
 taskService.addCandidateUser(secondTask.getId(), "liuxiaopeng");
 taskService.addUserIdentityLink(secondTask.getId(), "wangjunlin", "participant");
 //办理任务
 MyTaskService myTaskService = new MyTaskService(taskService);
 myTaskService.complete(secondTask.getId(), "huhaiqin");
 myTaskService.complete(secondTask.getId(), "wangjunlin");
 myTaskService.complete(secondTask.getId(), "liuxiaopeng");
 myTaskService.complete(secondTask.getId(), "hebo");
 
taskService任务执行
--------------------------------
（1）调用taskService的createTaskQuery()方法，创建一个任务查询对象，并指定查询条件taskId为传入的
	任务ID，通过调用任务查询对象的singleResult()方法获取符合条件的任务实例。如果没有找到，则任务可能
	已经办理，从运行时任务表ACT_RU_TASK中移除了。
	
（2）调用taskService的getIdentityLinksForTask()方法，获取任务的人员关系，找到传入参数userId和任务
	的关系，判断用户是否为任务候选人（其他人不允许办理任务），以实现任务的权限控制。
	
（3）如果步骤（2）判断用户任务候选人，先调用taskService的claim()方法认领任务，再调用taskService
	的complete()方法办理任务，并同时传入流程变量，为流程后续网关判断所用。

--------------------------------
历史服务API
--------------------------------
 //创建历史流程实例查询
 HistoricProcessInstanceQuery createHistoricProcessInstanceQuery(); 
 //创建历史活动实例查询
 HistoricActivityInstanceQuery createHistoricActivityInstanceQuery(); 
 //创建历史任务实例查询
 HistoricTaskInstanceQuery createHistoricTaskInstanceQuery(); 
 //创建历史详情查询
 HistoricDetailQuery createHistoricDetailQuery(); 
 //创建历史变量查询
 HistoricVariableInstanceQuery createHistoricVariableInstanceQuery(); 
 //查询流程实例历史日志
 ProcessInstanceHistoryLogQuery createProcessInstanceHistoryLogQuery(String 
 processInstanceId); 
 
 /*****创建原生查询，可以通过传入SQL进行检索*****/ 
 //创建通过SQL直接查询历史流程实例的对象
 NativeHistoricProcessInstanceQuery createNativeHistoricProcessInstanceQuery(); 
 //创建通过SQL直接查询历史活动实例的对象
 NativeHistoricActivityInstanceQuery createNativeHistoricActivityInstanceQuery(); 
 //创建通过SQL直接查询历史任务实例的对象
 NativeHistoricTaskInstanceQuery createNativeHistoricTaskInstanceQuery(); 
 //创建通过SQL直接查询历史详情的对象
 NativeHistoricDetailQuery createNativeHistoricDetailQuery(); 
 //创建通过SQL直接查询历史变量的对象
 NativeHistoricVariableInstanceQuery createNativeHistoricVariableInstanceQuery(); 
 
 //删除历史任务实例
 void deleteHistoricTaskInstance(String taskId); 
 //删除历史流程实例
 void deleteHistoricProcessInstance(String processInstanceId); 
 
 //查询与任务实例关联的用户
 List<HistoricIdentityLink> getHistoricIdentityLinksForTask(String taskId); 
 //查询与流程实例关联的用户
 List<HistoricIdentityLink> getHistoricIdentityLinksForProcessInstance(String processInstanceId);
 
示例代码
--------------------------------
 //查询历史流程实例
 List<HistoricProcessInstance> historicProcessInstances = 
 historyService.createNativeHistoricProcessInstanceQuery()
 .sql("select * from ACT_HI_PROCINST where BUSINESS_KEY_ like concat(#{prefix}, '%')")
 .parameter("prefix", businessKeyPrefix)
 .list();
 
 for (HistoricProcessInstance processInstance : historicProcessInstances) { 
 System.out.println(
	 "流程实例ID：" + processInstance.getId() 
	 + "，业务主键：" + processInstance.getBusinessKey() 
	 + "，创建时间：" + dateFormat.format(processInstance.getStartTime()) 
	 ); 
 }
 
 流程实例ID：5，业务主键：code_1，创建时间：2022-04-17 12:16:37.777 
 流程实例ID：10，业务主键：code_2，创建时间：2022-04-17 12:16:37.804 
 流程实例ID：15，业务主键：code_3，创建时间：2022-04-17 12:16:37.810

-------------------------------- 
管理服务API
--------------------------------

数据库管理
--------------------------------
ManagementService主要提供数据表和表元数据的管理和查询服务。

 //获取Activiti数据表名称和数据量
 Map<String, Long> getTableCount(); 
 //获取实体对应的表名
 String getTableName(Class<?> activitiEntityClass); 
 //查询指定表的元数据
 TableMetaData getTableMetaData(String tableName); 
 //获取表的分页查询对象
 TablePageQuery createTablePageQuery(); 
 //更新数据库schema 
 String databaseSchemaUpgrade(Connection connection, String catalog, String schema);
 
数据库管理代码示例
--------------------------------
 //获取数据表的名称及元数据
 String tableName = managementService
 .getTableName(HistoricProcessInstanceEntity.class); 
 
 System.out.println("HistoricProcessInstanceEntity对应的表名为：" + tableName);
 
 TableMetaData tableMetaData = managementService
 .getTableMetaData(tableName); 
 
 List<String> columnNames = tableMetaData
 .getColumnNames(); 
 for (String columnName : columnNames) { 
	System.out.println("--字段：" + columnName); 
 }
 
 //获取表的分页查询对象
 TablePage tablePage = managementService
 .createTablePageQuery() 
 .tableName(tableName) 
 .orderAsc("START_TIME_") 
 .listPage(1, 10); 
 
 System.out.println(tableName + "的记录数为：" + tablePage.getTotal());
 
异步任务管理
--------------------------------
ManagementService接口中关于异步任务管理的方法

 // 获取异步任务查询对象
 JobQuery createJobQuery(); 
 // 获取定时任务查询对象
 TimerJobQuery createTimerJobQuery(); 
 // 获取挂起任务查询对象
 SuspendedJobQuery createSuspendedJobQuery(); 
 // 获取不可执行任务查询对象
 DeadLetterJobQuery createDeadLetterJobQuery(); 
 // 强制执行任务
 void executeJob(String jobId); 
 // 将定时任务移入可执行任务
 Job moveTimerToExecutableJob(String jobId); 
 // 将任务移入不可执行任务
 Job moveJobToDeadLetterJob(String jobId); 
 // 将不可执行任务重新加入可执行任务
 Job moveDeadLetterJobToExecutableJob(String jobId, int retries); 
 // 删除异步任务
 void deleteJob(String jobId); 
 // 删除定时任务
 void deleteTimerJob(String jobId); 
 // 删除不可执行的任务
 void deleteDeadLetterJob(String jobId); 
 // 设置异步任务剩余重试次数
 void setJobRetries(String jobId, int retries); 
 // 设置定时任务剩余重试次数
 void setTimerJobRetries(String jobId, int retries); 
 // 获取异步任务异常栈
 String getJobExceptionStacktrace(String jobId); 
 // 获取定时任务异常栈
 String getTimerJobExceptionStacktrace(String jobId); 
 // 获取挂起任务异常栈
 String getSuspendedJobExceptionStacktrace(String jobId); 
 // 获取不可执行的任务异常栈
 String getDeadLetterJobExceptionStacktrace(String jobId);
 
 
代码示例
--------------------------------
 //查询第一个任务
 Task firstTask = taskService.createTaskQuery().processInstanceId( 
 processInstance.getId()).singleResult(); 
 //完成第一个任务
 taskService.complete(firstTask.getId()); 
 // 查询流程实例ID对应的job任务列表
 List<Job> timerJobs = managementService
 .createTimerJobQuery()
 .processInstanceId(processInstance.getId())
 .list();
 for (Job job : timerJobs) { 
	 System.out.println(
	 "定时任务" + job.getId() + 
	 "类型：" + job.getJobType() + 
	 "定时执行时间：" + dateFormat.format(job.getDuedate())); 
	 
	 managementService.moveTimerToExecutableJob(job.getId());
	 System.out.println("----立即执行任务" + job.getId()); 
	 managementService.executeJob(job.getId());
 }
 用ManagementService接口的createTimerJobQuery()方法查询定时任务
 用ManagementService()的moveTimerToExecutableJob()方法将定时任务移入执行任务列表
 用ManagementService的executeJob()方法立即执行该任务
 
执行命令
--------------------------------
ManagementService接口提供了两个executeCommand()方法用于执行自定义命令

执行命令 示例代码
--------------------------------
 //初始化工作流引擎
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 
 //准备参数
 Date curDate = new Date(); 
 System.out.println("当前时间为：" + curDate); 
 String express = "${dateFormat.format(date)}"; 
 Map<String, Object> variableMap = new HashMap<>(); 
 variableMap.put("date", curDate); 
 variableMap.put("dateFormat", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS")); 
 
 //调用执行表达式的CMD 
 Object result = managementService
 .executeCommand(new ExecuteExpressionCmd(express, variableMap));
 System.out.println("格式化后：" + result); 
 
 //关闭工作流引擎
 closeEngine();

--------------------------------
身份服务API
--------------------------------
Activiti使用ACT_ID_GROUP、ACT_ID_USER和ACT_ID_MEMBERSHIP这3张表维护人员组织架构

IdentityService接口方法
--------------------------------
 //新建用户
 User newUser(String userId); 
 //保存用户
 void saveUser(User user); 
 //创建用户查询
 UserQuery createUserQuery(); 
 //创建本地SQL查询
 NativeUserQuery createNativeUserQuery(); 
 //删除用户
 void deleteUser(String userId); 
 
 //新建组
 Group newGroup(String groupId); 
 //创建组查询对象
 GroupQuery createGroupQuery(); 
 //创建本地组SQL查询
 NativeGroupQuery createNativeGroupQuery(); 
 //保存组
 void saveGroup(Group group); 
 //删除组
 void deleteGroup(String groupId); 
 
 //创建用户与组的关系
 void createMembership(String userId, String groupId); 
 //删除用户与组的关系
 void deleteMembership(String userId, String groupId);
 
IdentityService接口主要提供以下3类方法。
--------------------------------
 与用户管理相关的方法：包括新建用户、保存用户、查询用户、删除用户等。
 与组管理相关的方法：包括新建组、保存组、查询组、删除组等。
 维护用户与组的关系的方法：包括新建关系、删除关系等。

身份服务示例代码
--------------------------------
 //初始化工作流引擎
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 
 //创建用户1 
 User user1 = identityService.newUser("huhaiqin"); 
 user1.setFirstName("胡"); 
 user1.setLastName("海琴"); 
 user1.setEmail("huhaiqin@activiti.org"); 
 
 //保存用户1 
 identityService.saveUser(user1); 
 
 //创建用户2 
 User user2 = identityService.newUser("liuxiaopeng"); 
 user2.setFirstName("刘"); 
 user2.setLastName("晓鹏"); 
 user2.setEmail("liuxiaopeng@activiti.org"); 
 
 //保存用户2 
 identityService.saveUser(user2); 
 
 //创建用户3 
 User user3 = identityService.newUser("hebo"); 
 user3.setFirstName("贺"); 
 user3.setLastName("波"); 
 user3.setEmail("hebo@activiti.org"); 
 
 //保存用户3 
 identityService.saveUser(user3); 
 
 //创建组1 
 Group group1 = identityService.newGroup("group1"); 
 group1.setName("Group1"); 
 
 //保存组1 
 identityService.saveGroup(group1); 
 
 //创建组2 
 Group group2 = identityService.newGroup("group2"); 
 group2.setName("Group2");
 
//查询组和用户
 List<Group> groups = identityService.createGroupQuery().list(); 
 for (Group group : groups) { 
 
	 System.out.println(
	 "组名：" + group.getName() + 
	 "组ID：" + group.getId()); 
	 
	 String groupId = group.getId(); 
	 List<User> users = identityService
	 .createUserQuery()
	 .memberOfGroup(groupId)
	 .list(); 
	 for (User user : users) { 
		 System.out.println(
		 "成员ID：" + user.getId()  + 
		 "姓名："   + user.getFirstName() + user.getLastName() +
		 "邮箱："   + user.getEmail()); 
	 } 
 } 
 //关闭工作流引擎
 closeEngine();

--------------------------------
第九章 Activiti身份管理
--------------------------------

用户管理
--------------------------------
 表ACT_ID_USER表用于存储用户数据
 一个User实例对应ACT_ID_USER表中的一条数据
 
USER表字段
-------------------------------- 
 id：用户ID，对应ACT_ID_USER表的ID_字段（主键）。
 firstName：用户的名称，对应ACT_ID_USER表的FIRST_字段。
 lastName：用户的姓氏，对应ACT_ID_USER表的LAST_字段。
 email：用户的电子邮箱，对应ACT_ID_USER表的EMAIL_字段。
 password：用户的密码，对应ACT_ID_USER表的PWD_字段。
 pictureByteArrayRef：用户的图片对象，其id属性对应ACT_ID_USER表的PICTURE_ID_字段。
 PICTURE_ ID_字段存储ACT_GE_BYTEARRAY表中存储图片二进制流记录的ID_字段的值。
 revision：用户的数据版本，对应ACT_ID_USER表的REV_字段。
 
 Activiti的org.activiti.engine.identity包主要用于进行身份管理和认证，
 基于IdentityService接口实现，IdentityService接口所有用户操作均围绕User进行
 
 
新建用户 示例代码
--------------------------------
 //调用IdentityService接口的newUser()方法创建User实例
 User newUser = identityService.newUser(id); 
 
 //调用setter()方法为创建的User实例设置属性值
 newUser.setFirstName(firstName); 
 newUser.setLastName(lastName); 
 newUser.setEmail(email);
 newUser.setPassword(password); 
 
 //调用IdentityService接口的saveUser()方法，将User实例存储到数据库
 identityService.saveUser(newUser);
 
查询用户
--------------------------------
 IdentityService提供了createUserQuery()方法
 createUserQuery()方法返回一个org.activiti.engine.query.Query实例
 Query是所有查询对象的父接口，定义了多种查询相关的方法，分别介绍如下
 asc()：设置查询结果的排序方式为升序。
 desc()：设置查询结果的排序方式为降序。
 list()：返回查询结果的集合，如果查不到，则返回一个空的集合。
 listPage()：分页返回查询结果的集合。
 count()：返回查询结果的数量。
 singleResult()：查询单条符合条件的记录。如果查询不到，则返回null；如果查询到多条记录，则抛出异常
 
list()方法
--------------------------------
Query接口list()方法以集合形式返回查询对象实体数据

示例代码
--------------------------------

List<User> users = userQuery.list(); 
 for (User user : users) { 
	 log.info(
	 "用户编号：{}，
	 姓名：{}，
	 邮箱：{}",
	 user.getId(), 
	 user.getLastName() + 
	 user.getFirstName() , 
	 user.getEmail()); 
 }
 

Activiti用户查询API支持的查询条件方法
--------------------------------
executeList(UserQuery userQuery) { 
 List<User> users = userQuery.list(); 
 for (User user : users) { 
	 log.info(
	 "用户编号：{}，
	 姓名：{}，
	 邮箱：{}", 
	 user.getId(), 
	 user. getLastName() + 
	 user.getFirstName() , 
	 user.getEmail()); 
 } 
}

 //根据查询条件查询匹配用户并输出用户信息
 UserQuery userQuery = identityService
 .createUserQuery()
 .userLastName("贺")
 .userEmailLike("%163.com%")
 .orderByUserId()
 .asc();
 UserUtil.executeList(userQuery);
 

以按照多个字段进行排序，如根据firstName降序排序后根据id升序排序
--------------------------------
 //根据查询条件查询用户并输出用户信息
 UserQuery userQuery = identityService.createUserQuery()
 .orderByUserLasttName().desc()
 .orderByUserId().asc();
 UserUtil.executeList(userQuery);
 
listPage()方法
--------------------------------
listPage()方法比list()方法多了firstResult和maxResults两个参数
listPage()方法同样支持链式编程

listPage()方法 示例代码
--------------------------------
executeListPage(UserQuery userQuery, int firstResult, int maxResults) {
	List<User> users = userQuery.listPage(firstResult, maxResults); 
	 for (User user : users) { 
		 log.info("用户编号：{}，姓名：{}，邮箱：{}", user.getId(), user.getLastName() + user.getFirstName() , user.getEmail()); 
	 }
}

 //分页查询用户并输出用户信息
 UserQuery userQuery = identityService.createUserQuery()
 .userEmailLike("%he%")
 .orderByUserId()
 .desc();
 
 UserUtil.executeListPage(userQuery, 1, 3);

count()方法
--------------------------------
调用count()方法可统计符合查询条件的查询结果的用户数量

示例代码
--------------------------------
executeCount(UserQuery userQuery) { 
 long userNum = userQuery.count();
 log.info("用户数为：{}", userNum); 
}

 //查询符合查询条件的用户数
 UserQuery userQuery = identityService.createUserQuery()
 .userLastName("贺")
 .userEmailLike("%he%");
 UserUtil.executeCount(userQuery);

singleResult()方法
--------------------------------
如果符合查询条件的记录多于一条，
Activiti会抛出org.activiti.engine.ActivitiException异常

executeSingleResult(UserQuery userQuery) { 
 User user = userQuery.singleResult();
 return user; 
}

 //查询符合条件的单个用户
 UserQuery userQuery = identityService.createUserQuery() 
 .userLastName("贺") 
 .userFirstName("波"); 
 User user = UserUtil.executeSingleResult(userQuery);
 
修改用户
--------------------------------
Activiti通过IdentityService服务修改用户的步骤如下
 获取单个User实例；
 调用setter()方法为User实例设置新属性值；
 调用IdentityService接口的saveUser(User user)方法将User实例更新保存到数据库
 
updateUser(IdentityService identityService, String id, 
 String newLastName, String newFirstName, String newEmail, String newPassword) { 
	 //查询用户信息
	 User user = executeSingleResult(identityService.createUserQuery().userId(id)); 
	 
	 //调用setter()方法为创建的User实例设置属性值
	 user.setFirstName(newFirstName); 
	 user.setLastName(newLastName); 
	 user.setEmail(newEmail); 
	 user.setPassword(newPassword); 
	 
	 //调用IdentityService的saveUser()方法将User实例存储到数据库
	 identityService.saveUser(user); 
}

 //加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 //新建用户
 UserUtil.addUser(identityService, 
 "hebo", "贺", "波", "hebo824@163.com", "******"); 
 
 //查询用户信息
 User oldUser = UserUtil
 .executeSingleResult(identityService.createUserQuery().userId("hebo")); 
 
 //输出原始用户信息
 log.info("修改前：id：{}，email：{}，password：{}", 
 oldUser.getId(), oldUser.getEmail(), oldUser.getPassword()); 
 
 //修改用户邮箱和密码
 UserUtil.updateUser(identityService, "hebo", oldUser.getFirstName(), 
 oldUser.getLastName(), "hebo@activiti.com", "######"); 
 
 //再次查询用户信息
 User newUser = UserUtil.executeSingleResult(identityService.createUserQuery().userId("hebo")); 
 log.info("修改后：id：{}，email：{}，password：{}", newUser.getId(), newUser.getEmail(),newUser.getPassword()); 

删除用户 代码示例
--------------------------------
deleteUser(IdentityService identityService, String id) { 
 identityService.deleteUser(id); 
}

//加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 //新建用户
 UserUtil.addUser(identityService, "zhangsan", "张", "三", "zhangsan@qq.com", "******"); 
 
 //查询用户信息
 User user = UserUtil.executeSingleResult(identityService.createUserQuery() .userId("zhangsan")); 
 log.info("用户编号：{}，姓名：{}，邮箱：{}", user.getId(), user.getLastName() +  user.getFirstName(), user.getEmail()); 
 
 //删除用户
 UserUtil.deleteUser(identityService,"zhangsan");
 
 //再次查询用户信息
 user = UserUtil.executeSingleResult(identityService.createUserQuery().userId("zhangsan")); 
 if (user == null) { 
	log.error("用户编号为{}的用户不存在", "zhangsan"); 
 }

 
设置用户图片 代码示例
--------------------------------
setPictureForUser(IdentityService identityService, String userId, File userPictureFile) {
	
	FileInputStream fileInputStream = new FileInputStream(userPictureFile); 
	BufferedImage bufferedImage = ImageIO.read(fileInputStream); 
	ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); 
	ImageIO.write(bufferedImage, "png", outputStream); 
	//将图片转换为byte数组
	byte[] pictureArray = outputStream.toByteArray(); 
	
	//创建用户图片的Picture实例
	Picture userPicture = new Picture(pictureArray, "the picture of user:" + userId);
	
	//为用户设置图片
	identityService.setUserPicture(userId, userPicture);
 }
 
 //加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 //新建用户
 UserUtil.addUser(identityService, 
 "hebo", "贺", "波", "hebo824@163.com", "******"); 
 //读取图片
 URL resource = RunSetUserPictureDemo.class.getClassLoader().getResource("pictures/photo.png"); 
 File userPictureFile = new File(resource.getPath()); 
 //为用户设置图片
 UserUtil.setPictureForUser(identityService, "hebo", userPictureFile);
 
用户组管理
--------------------------------
一个Group实例对应ACT_ID_GROUP表中的一条数据
 id：用户组ID，对应ACT_ID_GROUP表的ID_字段（主键）。
 name：用户组名称，对应ACT_ID_GROUP表的NAME_字段。
 type：用户组类型，对应ACT_ID_GROUP表的TYPE_字段。
 revision：用户组的数据版本，对应ACT_ID_GROUP表的REV_字段。
IdentityService对用户组的操作均围绕Group进行

用户组添加 示例代码
--------------------------------
addGroup(IdentityService identityService, String id, String name, String type) { 
 //调用IdentityService的newUser()方法创建User实例
 Group newGroup = identityService.newGroup(id); 
 //调用setter()方法为创建的User实例设置属性值
 newGroup.setName(name); 
 newGroup.setType(type); 
 //调用IdentityService的saveGroup()方法将Group实例保存到数据库
 identityService.saveGroup(newGroup); 
}

 //加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 GroupUtil.addGroup(identityService,"process_platform_department", "流程平台部", "department");
 
查询用户组
--------------------------------

list()方法
--------------------------------
executeList(GroupQuery groupQuery) { 
 List<Group> list = groupQuery.list();
 for (Group group : list) { 
	 log.info("
	 用户组编号：{}，
	 名称：{}，
	 类型：{}",
	 group.getId(), 
	 group.getName(), 
	 group.getType()); 
 } 
}

 //根据查询条件查询用户组并输出用户组信息
 GroupQuery groupQuery = identityService.createGroupQuery()
 .groupType("department")
 .orderByGroupId()
 .asc();
 GroupUtil.executeList(groupQuery);
 
listPage()方法
--------------------------------
executeListPage(GroupQuery groupQuery, int firstResult, int maxResults) { 
 List<Group> list = groupQuery.listPage(firstResult, maxResults); 
 for (Group group : list) { 
	log.info("用户组编号：{}，名称：{}，类型：{}", group.getId(), group.getName(), group.getType()); 
 } 
}

 GroupQuery groupQuery = identityService.createGroupQuery()
 .groupType("department")
 .orderByGroupId()
 .asc();
 GroupUtil.executeListPage(groupQuery,1,3);
 
count()方法
--------------------------------
executeCount(GroupQuery groupQuery) { 
 long groupNum = groupQuery.count(); 
 log.info("用户组数为：{}", groupNum); 
}

 //创建GroupQuery
 GroupQuery groupQuery = identityService.createGroupQuery().groupType("department");
 //统计用户组数量
 GroupUtil.executeCount(groupQuery);
 
singleResult()方法 示例代码
--------------------------------
executeSingleResult(GroupQuery groupQuery) { 
 Group group = groupQuery.singleResult(); 
 return group; 
}

 //创建GroupQuery
 GroupQuery groupQuery = identityService
 .createGroupQuery()
 .groupId("process_platform_department")
 .groupType("department");
 //查询单个用户组
 GroupUtil.executeSingleResult(groupQuery);
 
修改用户组
--------------------------------
updateGroup(IdentityService identityService, String groupId, String newName, String newType) { 
 //查询用户组信息
 Group group = executeSingleResult(identityService.createGroupQuery().groupId(groupId)); 
 
 //调用setter()方法为创建的Group实例设置属性值
 group.setName(newName); 
 group.setType(newType); 
 
 //调用IdentityService的saveGroup()方法将Group实例保存到数据库
 identityService.saveGroup(group); 
}

 //加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 //修改用户组信息
 GroupUtil.updateGroup(identityService,"process_platform_department","BPM平台部", "department");
 
删除用户组
--------------------------------
deleteGroup(IdentityService identityService, String groupId) {
	identityService.deleteGroup(groupId); 
}

 //加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 //删除用户组
 GroupUtil.deleteGroup(identityService,"testGroup");
 
用户与用户组关系管理
--------------------------------
过ACT_ID_MEMBERSHIP表存储用户与用户组的关联关系数据

添加用户至用户组
--------------------------------
addUserToGroup(IdentityService identityService, String userId, String groupId) { 
 identityService.createMembership(userId, groupId); 
}

 //加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 
 //新建用户
 UserUtil.addUser(identityService, "hebo", "贺", "波", "hebo@activiti.com", "******"); 
 
 //新建用户组
 GroupUtil.addGroup(identityService,"process_platform_department","流程平台部", "department"); 
 
 //将用户加入用户组
 identityService.createMembership("hebo", "process_platform_department");
 
从用户组中移除用户
--------------------------------
removeUserFromGroup(IdentityService identityService, String userId, String groupId) { 
 identityService.deleteMembership(userId, groupId); 
}

 //加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 //将用户从用户组中移除
 GroupUtil.removeUserFromGroup(identityService, "zhangsan", "testgroup");
 
查询用户组中的用户
--------------------------------
runRemoveUserFromGroupDemo() { 
 //加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 //将用户从用户组中移除
 GroupUtil.removeUserFromGroup(identityService, "zhangsan", "testgroup"); 
}

 //查询用户组中的用户
 UserQuery userQuery = identityService.createUserQuery()
 .memberOfGroup("process_platform_department")
 .orderByUserId()
 .asc();
 UserUtil.executeList(userQuery);

查询用户所在的用户组
--------------------------------
 //查询用户所在的用户组列表
 GroupQuery groupQuery = identityService.createGroupQuery()
 .groupMember("hebo")
 .orderByGroupId()
 .asc();
 GroupUtil.executeList(groupQuery);
 
用户附加信息管理
--------------------------------
Activiti默认的用户信息往往无法满足实际应用场景的需要
ACT_ID_INFO表可用于存储用户附加信息数据

用户附加信息 示例代码
--------------------------------
 //添加附加信息
 identityService.setUserInfo("hebo", "mobile", "13999999999"); 
 identityService.setUserInfo("hebo", "sex","男");

 //删除用户扩展属性可以通过调用IdentityService的deleteUserInfo()方法来实现，示例代码如下：
 identityService.deleteUserInfo("hebo","sex");

 //查询用户某个扩展属性的值
 String mobileStr = identityService.getUserInfo("hebo","mobile"); 
 log.info("mobileStr：{}", mobileStr);
 
getUserInfoKeys()方法查询用户所有扩展属性
--------------------------------
List<String> userInfoKeys = identityService.getUserInfoKeys("hebo"); 
for (String userInfoKey : userInfoKeys) { 
 String value = identityService.getUserInfo("hebo", userInfoKey); 
 log.info("userInfoKey：{}，value：{}", userInfoKey, value); 
}

--------------------------------
第十章 Activiti流程部署
--------------------------------

最常用的流程资源包括以下几种
--------------------------------
 流程定义文件：扩展名为.bpmn20.xm1或.bpmn。
 流程定义图片：用遵循BPMN 2.0规范的各种图形描绘的图片，通常为.png格式。
 表单文件：用于存储流程挂载的表单内容的文件，扩展名为.form。一个流程可以挂载多个表单。
 规则文件：使用Drools语法定义的规则，扩展名为.dr1。
 
流程部署
--------------------------------
第8章介绍过RepositoryService接口主要负责流程部署及流程定义管理
该接口提供了一个createDeployment()方法用于创建流程部署对象
DeploymentBuilder，并通过DeploymentBuilder对象实现流程部署

DeploymentBuilder对象
--------------------------------
DeploymentBuilder中定义了6种添加资源的方式

 //添加输入流资源
 DeploymentBuilder addInputStream(String resourceName, InputStream inputStream); 
 //添加classpath下的文件资源
 DeploymentBuilder addClasspathResource(String resource); 
 //添加字符串资源
 DeploymentBuilder addString(String resourceName, String text); 
 //添加字节数组资源
 DeploymentBuilder addBytes(String resourceName, byte[] bytes); 
 //添加ZIP压缩包资源
 DeploymentBuilder addZipInputStream(ZipInputStream zipInputStream); 
 //添加BpmnModel模型资源
 DeploymentBuilder addBpmnModel(String resourceName, BpmnModel bpmnModel); 
 
 //设置部署名称
 DeploymentBuilder name(String name); 
 //设置部署分类
 DeploymentBuilder category(String category); 
 //设置部署key
 DeploymentBuilder key(String key); 
 //设置租户ID 
 DeploymentBuilder tenantId(String tenantId); 
 //设置部署属性
 DeploymentBuilder deploymentProperty(String propertyKey, Object propertyValue); 
 
 //执行部署
 Deployment deploy();
 
执行流程部署
--------------------------------

添加输入流资源 代码示例
--------------------------------
 //从文件系统读取资源文件，创建输入流
 try (FileInputStream inputStream = new FileInputStream( 
	new File("/Users/bpm/processes/HolidayRequest.bpmn20.xml"))) { 
 
	 //创建DeploymentBuilder 
	 DeploymentBuilder builder = repositoryService.createDeployment(); 
	 
	 //将输入流传递给DeploymentBuilder，同时指定资源名称
	 builder.addInputStream("HolidayRequest.bpmn20.xml", inputStream);
	 
	 //执行部署
	 builder.deploy(); 
 }
 
Classpath下的文件资源 代码示例
--------------------------------
调用DeploymentBuilder的addClasspathResource()方法可以直接加载类路径下的资源文件
 //创建DeploymentBuilder 
 DeploymentBuilder builder = repositoryService.createDeployment(); 
 //加载classpath下的文件
 builder.addClasspathResource("processes/HolidayRequest.bpmn20.xml");
 //执行部署
 builder.deploy();
 
添加字符串资源 代码示例
--------------------------------
 //读取文件并转换为string 
 try (FileReader fileReader = 
 new FileReader(new File("/Users/bpm/processes/HolidayRequest.bpmn20.xml")); 
	 BufferedReader bufferedReader = new BufferedReader(fileReader);) { 
	 StringBuilder stringBuilder = new StringBuilder(); 
	 String line; 
	 while ((line = bufferedReader.readLine()) != null) { 
		stringBuilder.append(line); 
	 } 
	 //创建DeploymentBuilder 
	 DeploymentBuilder builder = repositoryService.createDeployment(); 
	 //将输入流传递给DeploymentBuilder，同时指定资源名称
	 builder.addString("HolidayRequest.bpmn20.xml", stringBuilder.toString());
	 //执行部署
	 builder.deploy(); 
 }
 
添加字节数组 代码示例
--------------------------------
//读取文件并转换为byte[] 
 try (FileInputStream inputStream = 
 new FileInputStream(new File("/Users/bpm/processes/HolidayRequest.bpmn20.xml")); 
	 ByteArrayOutputStream bos = new ByteArrayOutputStream();) { 
	 byte[] temp = new byte[1024]; 
	 int n; 
	 while ((n = inputStream.read(temp)) != -1) { 
		bos.write(temp, 0, n); 
	 } 
	 
	 //创建DeploymentBuilder 
	 DeploymentBuilder builder = repositoryService.createDeployment();
	 
	 //将字节数组传递给DeploymentBuilder，同时指定资源名称
	 builder.addBytes("HolidayRequest.bpmn20.xml", bos.toByteArray());
	 
	 //执行部署
	 builder.deploy();
	}
	
添加压缩包资源 代码示例
--------------------------------
//读取ZIP文件
 try (FileInputStream inputStream = 
 new FileInputStream(new File("/Users/bpm/processes/HolidayRequest.zip")); 
	 ZipInputStream zipInputStream = new ZipInputStream(inputStream);) { 
	 //创建DeploymentBuilder 
	 DeploymentBuilder builder = repositoryService.createDeployment(); 
	 //传递ZIP输入流给DeploymentBuilder 
	 builder.addZipInputStream(zipInputStream);
	 //执行部署
	 builder.deploy(); 
 }
 
添加BpmnModel模型资源
--------------------------------
 //创建BpmnModel对象
 BpmnModel model = new BpmnModel(); 
 
 //创建流程(Process) 
 org.activiti.bpmn.model.Process process = new org.activiti.bpmn.model.Process(); 
 model.addProcess(process); 
 process.setId("HolidayRequest"); 
 process.setName("请假申请流程"); 
 
 //创建开始节点
 StartEvent startEvent = new StartEvent(); 
 startEvent.setId("startEvent1"); 
 startEvent.setName("开始"); 
 process.addFlowElement(startEvent);
 
 //创建任务节点
 UserTask userTask1 = new UserTask(); 
 userTask1.setId("userTask1"); 
 userTask1.setName("申请"); 
 process.addFlowElement(userTask1);
 
 //创建任务节点
 UserTask userTask2 = new UserTask(); 
 userTask2.setId("userTask2"); 
 userTask2.setName("审批"); 
 process.addFlowElement(userTask2); 
 
 //创建结束节点
 EndEvent endEvent = new EndEvent(); 
 endEvent.setId("endEvent1"); 
 endEvent.setName("结束"); 
 process.addFlowElement(endEvent); 
 
 //创建节点的关联关系
 process.addFlowElement(new SequenceFlow("startEvent1", "userTask1")); 
 process.addFlowElement(new SequenceFlow("userTask1", "userTask2")); 
 process.addFlowElement(new SequenceFlow("userTask2", "endEvent1")); 
 
 //创建DeploymentBuilder 
 DeploymentBuilder builder = repositoryService.createDeployment(); 
 
 //传递BpmnModel给DeploymentBuilder 
 builder.addBpmnModel("HolidayRequest.bpmn20.xml", model);
 
 //执行部署
 builder.deploy();
 
部署结果查询
--------------------------------
流程部署主要涉及3个表：
部署记录表（ACT_RE_DEPLOYMENT，主要用于存储流程部署记录）
流程定义表（ACT_RE_PROCDEF，主要用于存储流程定义信息）
静态资源表（ACT_GE_BYTEARRAY，主要用于存储静态资源文件，如BPMN文件和流程缩略图）

 id：部署ID，继承自父类AbstractEntityNoRevision的id属性，对应ACT_RE_DEPLOYMENT表的ID_字段（主键）。
 name：部署名称，对应ACT_RE_DEPLOYMENT表的NAME_字段。
 category：流程部署分类，对应ACT_RE_DEPLOYMENT表的CATEGORY_字段。
 key：流程部署的key，对应ACT_RE_DEPLOYMENT表的KEY_字段。
 tenantId：租户ID，对应ACT_RE_DEPLOYMENT表的TENANT_ID_字段。
 resources：关联的资源文件。该属性是一个Map，前面介绍的DeploymentBuilder加载流程资源的方法
 engineVersion：工作流引擎版本，主要用于解决工作流引擎向后兼容的问题，对应ACT_RE_DEPLOYMENT表ENGINE_VERSION_字段。
 deploymentTime：部署时间，对应ACT_RE_DEPLOYMENT表DEPLOY_TIME_字段。

DeploymentEntityManager
--------------------------------
DeploymentEntityManager接口继承自EntityManager接口，
支持对ACT_RE_DEPLOYMENT表进行通用的增、删、改、查操作

 //根据部署名称查找最新的部署记录
 DeploymentEntity findLatestDeploymentByName(String deploymentName); 
 
 //根据部署记录ID查询部署资源名称
 List<String> getDeploymentResourceNames(String deploymentId);
 
 //原生查询，返回分页记录
 List<Deployment> findDeploymentsByNativeQuery(Map<String, Object> parameterMap, int firstResult, int maxResults);
 
 //原生查询，返回记录数量
 long findDeploymentCountByNativeQuery(Map<String, Object> parameterMap); 
 
 //根据DeploymentQuery查询，返回分页记录
 List<Deployment> findDeploymentsByQueryCriteria(DeploymentQueryImpl deploymentQuery, Page page); 
 
 //根据DeploymentQuery查询，返回记录数量
 long findDeploymentCountByQueryCriteria(DeploymentQueryImpl deploymentQuery);
 
 //级联删除部署记录
 void deleteDeployment(String deploymentId, boolean cascade);
 
DeploymentQuery
--------------------------------
DeploymentQuery接口继承自Query接口，支持Query接口中的所有查询方法

 //按排序条件升序排列
 T asc(); 
 //按排序条件降序排列
 T desc(); 
 //执行查询并返回结果集数量
 long count(); 
 //执行查询并返回唯一结果，没有找到返回null，结果数量大于1时报错
 U singleResult(); 
 //执行查询并返回结果集
 List<U> list(); 
 //执行分页查询并返回结果集
 List<U> listPage(int firstResult, int maxResults);
 
ProcessDefinitionEntity接口的实现类为ProcessDefinitionEntityImpl，该类对应ACT_RE_PROCDEF表。
ProcessDefinitionEntityImpl类包含以下属性。


ProcessDefinitionEntity
--------------------------------
ProcessDefinitionEntity接口的实现类为ProcessDefinitionEntityImpl，该类对应ACT_RE_PROCDEF表

 id：流程定义ID，继承自AbstractEntity类的id属性，对应ACT_RE_PROCDEF表的ID_字段（主键）。
 description：流程描述，对应ACT_RE_PROCDEF表的DESCRIPTION_字段。
 key：流程的key，对应ACT_RE_PROCDEF表的KEY_字段。
 version：流程的版本，对应ACT_RE_PROCDEF表的REV_字段，同一个key可以对应多个版本，不同版本之间流程定义的ID是不同的。
 category：流程分类，对应ACT_RE_PROCDEF表的CATEGORY_字段。
 deploymentId ：部署 ID ，对应 ACT_RE_PROCDEF 表 的 DEPLOYMENT_ID_字段，与 ACT_RE_ DEPLOYMENT表中的ID_字段关联。
 resourceName：资源名称，对应ACT_RE_PROCDEF表的RESOURCE_NAME_字段。
 tenantId：租户ID，对应ACT_RE_PROCDEF表的TENANT_ID_字段。
 historyLevel：历史数据级别，在ACT_RE_PROCDEF表中没有对应字段，主要用于判断流程执行过程中是否需要保存历史数据。
 diagramResourceName：图片资源名称，对应ACT_RE_PROCDEF表的DGRM_RESOURCE_NAME_字段。
 variables：流程定义变量信息，类型为Map，在ACT_RE_PROCDEF表中没有对应字段。
 isGraphicalNotationDefined：是否有图片信息，对应ACT_RE_PROCDEF表的HAS_GRAPHICAL_NOTATION_字段。
 hasStartFormKey：是否存在发起表单，对应ACT_RE_PROCDEF表的HAS_START_FORM_KEY_字段。
 suspensionState：挂起状态，对应ACT_RE_PROCDEF表的SUSPENSION_STATE_字段，已挂起的流程定义不能再发起和流转。
 engineVersion：工作流引擎版本，主要用于解决工作流引擎向后兼容的问题，对应ACT_RE_PROCDEF表的ENGINE_VERSION_字段。
 
ProcessDefinitionEntityManager
--------------------------------
ProcessDefinitionEntityManager接口继承自EntityManager接口，支持对ACT_RE_PROCDEF表进行通用的增、删、改、查操作。
 
 //根据流程定义key查找最新的流程定义
 ProcessDefinitionEntity findLatestProcessDefinitionByKey(String processDefinitionKey);
 
 //根据流程定义key和租户ID查找最新的流程定义
 ProcessDefinitionEntity findLatestProcessDefinitionByKeyAndTenantId(String processDefinitionKey, String tenantId); 
 
 //根据ProcessDefinitionQuery条件查询，返回分页记录
 List<ProcessDefinition> 
 findProcessDefinitionsByQueryCriteria(ProcessDefinitionQueryImpl processDefinitionQuery, Page page); 
 
 //根据ProcessDefinitionQuery条件查询，返回记录数量
 long findProcessDefinitionCountByQueryCriteria(ProcessDefinitionQueryImpl processDefinitionQuery); 
 
 //根据部署ID和流程定义key查找
 ProcessDefinitionEntity findProcessDefinitionByDeploymentAndKey(String deploymentId, String processDefinitionKey); 
 
 //根据部署ID、流程定义key和租户ID查找
 ProcessDefinitionEntity findProcessDefinitionByDeploymentAndKeyAndTenantId(String deploymentId, String processDefinitionKey, String tenantId); 

 //根据流程定义key、流程定义版本和租户ID查找
 ProcessDefinition findProcessDefinitionByKeyAndVersionAndTenantId(String processDefinitionKey, Integer processDefinitionVersion, String tenantId); 
 
 //原生查询，返回分页记录
 List<ProcessDefinition> findProcessDefinitionsByNativeQuery(Map<String, Object> parameterMap, int firstResult, int maxResults); 

 //原生查询，返回记录数量
 long findProcessDefinitionCountByNativeQuery(Map<String, Object> parameterMap); 

 //根据部署ID更新相应流程定义的租户ID 
 void updateProcessDefinitionTenantIdForDeployment(String deploymentId, String newTenantId); 

 //根据部署ID删除流程定义
 void deleteProcessDefinitionsByDeploymentId(String deploymentId);
 
ProcessDefinitionQuery
--------------------------------
该接口提供了多种查询方法，实现了根据流程定义ID查询、根据流程定义key查询、根据流程名称查询等操作

查询方法 说明
processDefinitionId(String processDefinitionId) 通过指定的流程定义ID查询
processDefinitionIds(Set<String> processDefinitionIds) 根据一组流程定义ID批量查询
processDefinitionCategory (String processDefinitionCategory) 根据流程分类查询
processDefinitionCategoryLike (String processDefinitionCategoryLike) 根据流程分类模糊查询
processDefinitionCategoryNotEquals (String categoryNotEquals) 查询排除某个分类后的流程定义
processDefinitionName(String processDefinitionName) 根据流程定义名称查询
processDefinitionNameLike (String processDefinitionNameLike) 根据流程定义名称模糊查询

Activiti流程定义查询API支持的排序方法
--------------------------------
orderByProcessDefinitionCategory() 按流程分类排序，还需要指定升序或降序排列
orderByProcessDefinitionKey() 按流程定义key排序，还需要指定升序或降序排列
orderByProcessDefinitionId() 按流程定义ID排序，还需要指定升序或降序排列
orderByProcessDefinitionVersion() 按流程版本号排序，还需要指定升序或降序排列
orderByProcessDefinitionName() 按流程定义名称排序，还需要指定升序或降序排列
orderByDeploymentId() 按部署ID排序，还需要指定升序或降序排列
orderByTenantId() 按租户ID排序，还需要指定升序或降序排列

--------------------------------
queryProcessDefinitionByTenantId(String tenantId) { 
 return repositoryService.createProcessDefinitionQuery() 
 //指定流程定义key 
 .processDefinitionTenantId(tenantId) 
 //按流程key排序
 .orderByProcessDefinitionKey() 
 //升序
 .asc() 
 //返回全部记录
 .list(); 
}

流程资源查询
--------------------------------
流程资源存储在ACT_GE_BYTEARRAY表中，Activiti中的实体类ResourceEntity与该资源表相对应

ResourceEntity
--------------------------------
ACT_GE_BYTEARRAY表是一个公共表，用于存储所有静态资源信息，
包括流程部署资源文件，如流程的BPMN文件、流程缩略图、表单模型、规则文件等。

 id：资源ID，继承自AbstractEntityNoRevision类，对应ACT_GE_BYTEARRAY表的ID_字段（主键）。
 name：资源名称，对应ACT_GE_BYTEARRAY表的NAME_字段。
 bytes：资源内容，以二进制形式保存，对应ACT_GE_BYTEARRAY表的BYTES_字段。
 deploymentId：部署ID，对应ACT_GE_BYTEARRAY表的DEPLOYMENT_ID_字段，与ACT_RE_DEPLOYMENT表中的ID_字段相关联。
 generated：标识对应的资源是否是由系统生成，对应ACT_GE_BYTEARRAY表的GENERATED_字段。
 
ResourceEntityManager
--------------------------------
ResourceEntityManager接口继承自EntityManager接口，
支持对ACT_GE_BYTEARRAY表进行通用的增、删、改、查操作

 //根据部署ID查询资源列表
 List<ResourceEntity> findResourcesByDeploymentId(String deploymentId); 
 
 //根据部署ID和资源名称查询资源
 ResourceEntity findResourceByDeploymentIdAndResourceName( String deploymentId, String resourceName); 
 
 //根据部署ID删除资源
 void deleteResourcesByDeploymentId(String deploymentId);
 
getResources() { 
 if (resources == null && id != null) { 
 List<ResourceEntity> resourcesList = Context.getCommandContext(). 
 getResourceEntityManager().findResourcesByDeploymentId(id);
 resources = new HashMap<String, ResourceEntity>(); 
 for (ResourceEntity resource : resourcesList) {
	 resources.put(resource.getName(), resource); 
 } 
}

流程部署完整示例
--------------------------------
 //加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 
 //部署流程
 Deployment deployment = repositoryService.createDeployment() 
 
 //设置部署基本属性
 .key("HolidayRequest") 
 .name("请假申请") 
 .category("HR") 
 .tenantId("HR") 
 //添加classpath下的流程定义资源
 .addClasspathResource("processes/HolidayRequest.bpmn20.xml") 
 //执行部署
 .deploy(); 
 
 log.info("部署记录：deployment_id={}, deployment_name={}", 
 deployment.getId(), deployment.getName()); 
 
 //查询流程资源
 log.info("部署资源:"); 
 if (deployment instanceof DeploymentEntity) { 
	 DeploymentEntity entity = (DeploymentEntity) deployment; 
	 Map<String, ResourceEntity> resourceEntityMap = entity.getResources(); 
	 for (Map.Entry<String, ResourceEntity> resourceEntity : 
		 resourceEntityMap.entrySet()) { 
		 ResourceEntity entityValue = resourceEntity.getValue(); 
		 log.info(" 
		 resource_name={}, 
		 deployment_id={}", 
		 entityValue.getName(), 
		 entityValue.getDeploymentId()); 
	 } 
 } 
 //查询流程定义
 ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery() 
 //指定流程定义key
 .processDefinitionKey("HolidayRequest") 
 //指定激活状态
 .active() 
 //查找最新版本
 .latestVersion() 
 //返回单个记录
 .singleResult(); 
 log.info("流程定义:processDefinition_id={}, 
 processDefinition_key={}",processDefinition.getId(),processDefinition.getName()); 
 //关闭工作流引擎
 closeEngine();
 
相关表的变更
--------------------------------
Activiti都会向部署记录表（ACT_RE_DEPLOYMENT）、流程定义表（ACT_RE_PROCDEF）和静态资源表（ACT_GE_BYTEARRAY）中插入相应的记录。
其中，ACT_RE_DEPLOYMENT为主表，ACT_RE_PROCDEF和ACT_GE_BYTEARRAY通过DEPLOYMENT_ID_字段与ACT_RE_DEPLOYMENT的主键ID_字段关联


--------------------------------
第十一章 开始事件与结束事件
--------------------------------

事件概述
--------------------------------
在BPMN 2.0中，事件用圆圈符号表示。
按照特性分类，可以将其分为两大类。
捕获（catching）事件
抛出（throwing）事件

捕获事件：当流程执行到该事件时，它会中断执行，等待被触发。其触发类型由XML定义文件中的类型声明决定。

抛出事件：当流程执行到该事件时，会抛出一个结果。抛出的类型由XML定义文件中的类型声明决定。

捕获事件的内部图标填充为白色
抛出事件的内部图标填充为黑色

总的来说，BPMN 2.0支持60多种不同类型的事件

主要有三大类型事件：开始事件、中间事件（包括中间事件和边界事件）和结束事件。

 定时器事件定义（timer event definition）
 信号事件定义（signal event definition）
 错误事件定义（error event definition）
 消息事件定义（message event definition）
 取消事件定义（cancel event definition）
 补偿事件定义（compensate event definition）
 终止事件定义（terminate event definition）
 
 
--------------------------------
边界事件与中间事件
--------------------------------
边界事件是依附在活动上的“捕获型”事件，会一直监听所有进行时活动的某种事件的触发，
然后沿边界事件的外出顺序流继续流转，如果是中断事件会终止所依附的活动。
中间事件提供的特殊功能可以用于处理流程执行过程中抛出、捕获的事件

--------------------------------
第十三章 用户任务、手动任务和接收任务
--------------------------------
1.用户任务指需要人工参与完成的工作
2.手动任务指会自动执行的一种任务
3.接收任务指会使流程处于等待状态、需要触发的任务

用户任务
--------------------------------
用户任务是常见的一类任务，指业务流程中需要人工参与完成的工作。

 分配到一个用户（私有任务）；
 共享给多个用户（共享任务）。
 
 在大部分的流程场景中，一个用户任务通常被具体指派给一个人进行处理，
 通过这种方式指派的人在Activiti中称为办理人
 
 而在某些业务处理场景中，一个任务可以被共享给多人，
 这类任务在工作流引擎中只创建一个任务实例，
 它会出现在所有候选人和候选组成员的待办中，
 这些人都有权认领（claim）并完成该任务
 
提示：一个用户任务只允许分配一个办理人，但可以分配多个候选人（组）。

用户任务 代码示例
--------------------------------
 //加载Activiti配置文件并初始化工作流引擎及服务
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 //部署流程
 ProcessDefinition processDefinition = 
 deployByClasspathResource("processes/UserTaskProcess.bpmn20.xml"); 
 
 //启动流程
 ProcessInstance processInstance =
 runtimeService.startProcessInstanceById(processDefinition.getId()); 
 //查询第一个任务
 Task firstTask = 
 taskService.createTaskQuery().processInstanceId(processInstance. 
 getProcessInstanceId()).singleResult(); 
 
 log.info("第一个任务taskId：{}，taskName为：{}", firstTask.getId(), firstTask.getName()); 
 log.info("用户任务描述信息为：{}", firstTask.getDescription()); 
 log.info("用户任务创建时间为：{}", getStringDate(firstTask.getCreateTime())); 
 
 //设置流程变量
 Map variables = new HashMap<>(); 
 variables.put("dayNum", 3); 
 variables.put("applyReason", "休探亲假。"); 
 
 //办理第一个任务
 taskService.complete(firstTask.getId(), variables); 
 
 //查询第二个任务
 Task secondTask = 
 taskService.createTaskQuery().processInstanceId(processInstance. 
 getProcessInstanceId()).singleResult(); 
 
 log.info("第二个任务taskId：{}，taskName为：{}", secondTask.getId(), secondTask.getName()); 
 log.info("用户任务描述信息为：{}", secondTask.getDescription()); 
 log.info("用户任务创建时间为：{}，过期时间为：{}", 
 getStringDate(secondTask.getCreateTime()), getStringDate(secondTask.getDueDate())); 
 
 //关闭工作流引擎
 closeEngine();