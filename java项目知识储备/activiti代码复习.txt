流程部署配置
--------------------------------
 //创建工作流引擎配置
 ProcessEngineConfigurationImpl processEngineConfiguration = 
 (ProcessEngineConfigurationImpl) ProcessEngineConfiguration 
 .createProcessEngineConfigurationFromResource("activiti.cfg.xml"); 
 //创建工作流引擎
 ProcessEngine engine = processEngineConfiguration.buildProcessEngine();

--------------------------------
存储服务API
--------------------------------

部署流程定义
--------------------------------
 //获取流程存储服务
 RepositoryService repositoryService = engine.getRepositoryService();
 //部署流程
 Deployment deployment = repositoryService
 .createDeployment()
 .addClasspathResource("processes/SimpleProcess.bpmn20.xml")
 .deploy();
 
 //查询流程定义
 ProcessDefinition processDefinition = repositoryService
 .createProcessDefinitionQuery() 
 .deploymentId(deployment.getId())
 .singleResult(); 
 
 System.out.println(
 "流程定义ID为：" + processDefinition.getId() + 
 "，流程名称为：" + processDefinition.getName() + 
 "，版本号：" + processDefinition.getVersion());

删除流程定义
--------------------------------
 //删除指定的部署，不进行级联删除
 void deleteDeployment(String deploymentId);
 //可级联删除指定的部署，级联删除包括删除流程实例、job等
 void deleteDeployment(String deploymentId, boolean cascade);
 
 第一个方法只有一个参数deploymentId，
 第二个方法增加了一个cascade参数，用于指定是否进行级联删除
 不管是否指定进行级联删除，流程部署信息、流程定义数据、资源数据等都会被删除。
 如果指定进行级联删除，会同时删除流程对应的运行时流程实例、历史流程实例、关联的job等。
 
挂起流程定义
--------------------------------
 如果暂时不想再使用部署后的流程定义，则可以挂起。
 RepositoryService接口中提供了多种挂起流程定义的方法：
 //根据流程定义ID 立即挂起
 void suspendProcessDefinitionById(String processDefinitionId); 
 //根据流程定义ID在指定日期挂起
 void suspendProcessDefinitionById(String processDefinitionId, boolean suspendProcessInstances, Date suspensionDate); 
 //根据流程定义key立即挂起
 void suspendProcessDefinitionByKey(String processDefinitionKey); 
 //根据流程定义key在指定日期挂起
 void suspendProcessDefinitionByKey(String processDefinitionKey, boolean 
 suspendProcessInstances, Date suspensionDate); 
 //根据流程定义key和租户ID立即挂起
 void suspendProcessDefinitionByKey(String processDefinitionKey, String tenantId); 
 //根据流程定义key和租户ID在指定日期挂起
 void suspendProcessDefinitionByKey(String processDefinitionKey, boolean 
 suspendProcessInstances, Date suspensionDate, String tenantId);

激活流程定义
--------------------------------
 //根据流程定义ID立即激活
 void activateProcessDefinitionById(String processDefinitionId); 
 //根据流程定义ID在指定日期激活
 void activateProcessDefinitionById(String processDefinitionId, 
 boolean activateProcessInstances, Date activationDate); 
 //根据流程定义key立即激活
 void activateProcessDefinitionByKey(String processDefinitionKey); 
 //根据流程定义key在指定日期激活
 void activateProcessDefinitionByKey(String processDefinitionKey, 
 boolean activateProcessInstances, Date activationDate); 
 //根据流程定义key和租户ID立即激活
 void activateProcessDefinitionByKey(String processDefinitionKey, String tenantId); 
 //根据流程定义key和租户ID在指定日期激活
 void activateProcessDefinitionByKey(String processDefinitionKey, 
 boolean activateProcessInstances, Date activationDate, String tenantId);

-------------------------------- 
运行时服务API
--------------------------------

发起流程实例
--------------------------------
 //初始化工作流引擎
 loadActivitiConfigAndInitEngine("activiti.cfg.xml"); 
 //部署流程
 ProcessDefinition processDefinition = 
 deployByClasspathResource("processes/SimpleProcess.bpmn20.xml"); 
 System.out.println("流程定义ID为：" + processDefinition.getId() + "，流程定义key为："+ processDefinition.getKey());
 
 //根据流程定义ID发起流程
 ProcessInstance processInstance = runtimeService
 .startProcessInstanceById(processDefinition.getId());
 queryProcessInstance(processInstance.getId()); 
 
 //根据流程定义key发起流程
 ProcessInstance processInstance2 = runtimeService
 .createProcessInstanceBuilder()
 .processDefinitionKey(processDefinition.getKey())
 .name("SimpleProcessInstance")
 .start();
 
唤醒一个等待状态的执行
--------------------------------
 RuntimeService接口提供了
 
 //唤醒等待状态的执行
 void trigger(String executionId); 
 //唤醒等待状态的执行，同时传入新的流程变量
 void trigger(String executionId, Map<String, Object> processVariables); 
 //唤醒等待状态的执行，同时传入新的流程变量和瞬时变量
 void trigger(String executionId, Map<String, Object> processVariables, Map<String, Object> transientVariables);

--------------------------------
任务服务API
--------------------------------

待办任务查询
--------------------------------
TaskService 接口提供了
 //创建任务查询对象
 TaskQuery createTaskQuery(); 
 
 //创建通过SQL直接查询任务的对象
 NativeTaskQuery createNativeTaskQuery();

待办任务查询 示例代码 
-------------------------------- 
 //查询用户待办任务
 List<Task> taskList = taskService
 .createTaskQuery()
 .taskCandidateOrAssigned(userId)
 .orderByTaskCreateTime().desc().list();
 
 if (taskList != null && taskList.size() > 0) { 
 for (Task task : taskList) { 
	System.out.println(
	"任务[" + task.getName() + "]
	(ID=" + task.getId() + ")" + 
	"的办理人为：" + task.getAssignee() + 
	"，创建时间为：" + dateFormat.format(task.getCreateTime()) 
	);
 }
 
任务办理及权限控制
--------------------------------
TaskService接口提供了多种任务办理方法，以及人员与任务关系管理方法
 //任务办理相关设置
 void claim(String taskId, String userId); 
 void unclaim(String taskId); 
 void delegateTask(String taskId, String userId); 
 void resolveTask(String taskId); 
 void resolveTask(String taskId, Map<String, Object> variables); 
 void resolveTask(String taskId, Map<String, Object> variables, 
 Map<String, Object> transientVariables); 
 void complete(String taskId); 
 void complete(String taskId, Map<String, Object> variables); 
 void complete(String taskId, Map<String, Object> variables, 
 Map<String, Object> transientVariables); 
 void complete(String taskId, Map<String, Object> variables, boolean localScope); 
 
 //人员与任务关系管理
 void setAssignee(String taskId, String userId); 
 void setOwner(String taskId, String userId); 
 void addCandidateUser(String taskId, String userId); 
 void addCandidateGroup(String taskId, String groupId); 
 void addUserIdentityLink(String taskId, String userId, String identityLinkType); 
 void addGroupIdentityLink(String taskId, String groupId, String identityLinkType); 
 void deleteCandidateUser(String taskId, String userId); 
 void deleteCandidateGroup(String taskId, String groupId); 
 void deleteUserIdentityLink(String taskId, String userId, String identityLinkType); 
 void deleteGroupIdentityLink(String taskId, String groupId, String identityLinkType); 
 List<IdentityLink> getIdentityLinksForTask(String taskId);
 
示例代码 
--------------------------------
 //设置任务与人员的关系
 taskService.addCandidateUser(secondTask.getId(), "hebo");
 taskService.addCandidateUser(secondTask.getId(), "liuxiaopeng");
 taskService.addUserIdentityLink(secondTask.getId(), "wangjunlin", "participant");
 //办理任务
 MyTaskService myTaskService = new MyTaskService(taskService);
 myTaskService.complete(secondTask.getId(), "huhaiqin");
 myTaskService.complete(secondTask.getId(), "wangjunlin");
 myTaskService.complete(secondTask.getId(), "liuxiaopeng");
 myTaskService.complete(secondTask.getId(), "hebo");
 
taskService任务执行
--------------------------------
（1）调用taskService的createTaskQuery()方法，创建一个任务查询对象，并指定查询条件taskId为传入的
	任务ID，通过调用任务查询对象的singleResult()方法获取符合条件的任务实例。如果没有找到，则任务可能
	已经办理，从运行时任务表ACT_RU_TASK中移除了。
	
（2）调用taskService的getIdentityLinksForTask()方法，获取任务的人员关系，找到传入参数userId和任务
	的关系，判断用户是否为任务候选人（其他人不允许办理任务），以实现任务的权限控制。
	
（3）如果步骤（2）判断用户任务候选人，先调用taskService的claim()方法认领任务，再调用taskService
	的complete()方法办理任务，并同时传入流程变量，为流程后续网关判断所用。

--------------------------------
历史服务API
--------------------------------
 //创建历史流程实例查询
 HistoricProcessInstanceQuery createHistoricProcessInstanceQuery(); 
 //创建历史活动实例查询
 HistoricActivityInstanceQuery createHistoricActivityInstanceQuery(); 
 //创建历史任务实例查询
 HistoricTaskInstanceQuery createHistoricTaskInstanceQuery(); 
 //创建历史详情查询
 HistoricDetailQuery createHistoricDetailQuery(); 
 //创建历史变量查询
 HistoricVariableInstanceQuery createHistoricVariableInstanceQuery(); 
 //查询流程实例历史日志
 ProcessInstanceHistoryLogQuery createProcessInstanceHistoryLogQuery(String 
 processInstanceId); 
 
 /*****创建原生查询，可以通过传入SQL进行检索*****/ 
 //创建通过SQL直接查询历史流程实例的对象
 NativeHistoricProcessInstanceQuery createNativeHistoricProcessInstanceQuery(); 
 //创建通过SQL直接查询历史活动实例的对象
 NativeHistoricActivityInstanceQuery createNativeHistoricActivityInstanceQuery(); 
 //创建通过SQL直接查询历史任务实例的对象
 NativeHistoricTaskInstanceQuery createNativeHistoricTaskInstanceQuery(); 
 //创建通过SQL直接查询历史详情的对象
 NativeHistoricDetailQuery createNativeHistoricDetailQuery(); 
 //创建通过SQL直接查询历史变量的对象
 NativeHistoricVariableInstanceQuery createNativeHistoricVariableInstanceQuery(); 
 
 //删除历史任务实例
 void deleteHistoricTaskInstance(String taskId); 
 //删除历史流程实例
 void deleteHistoricProcessInstance(String processInstanceId); 
 
 //查询与任务实例关联的用户
 List<HistoricIdentityLink> getHistoricIdentityLinksForTask(String taskId); 
 //查询与流程实例关联的用户
 List<HistoricIdentityLink> getHistoricIdentityLinksForProcessInstance(String processInstanceId);
 
示例代码
--------------------------------
 //查询历史流程实例
 List<HistoricProcessInstance> historicProcessInstances = 
 historyService.createNativeHistoricProcessInstanceQuery()
 .sql("select * from ACT_HI_PROCINST where BUSINESS_KEY_ like concat(#{prefix}, '%')")
 .parameter("prefix", businessKeyPrefix)
 .list();
 
 for (HistoricProcessInstance processInstance : historicProcessInstances) { 
 System.out.println(
	 "流程实例ID：" + processInstance.getId() 
	 + "，业务主键：" + processInstance.getBusinessKey() 
	 + "，创建时间：" + dateFormat.format(processInstance.getStartTime()) 
	 ); 
 }
 
 流程实例ID：5，业务主键：code_1，创建时间：2022-04-17 12:16:37.777 
 流程实例ID：10，业务主键：code_2，创建时间：2022-04-17 12:16:37.804 
 流程实例ID：15，业务主键：code_3，创建时间：2022-04-17 12:16:37.810

-------------------------------- 
管理服务API
--------------------------------

数据库管理
--------------------------------
ManagementService主要提供数据表和表元数据的管理和查询服务。

 //获取Activiti数据表名称和数据量
 Map<String, Long> getTableCount(); 
 //获取实体对应的表名
 String getTableName(Class<?> activitiEntityClass); 
 //查询指定表的元数据
 TableMetaData getTableMetaData(String tableName); 
 //获取表的分页查询对象
 TablePageQuery createTablePageQuery(); 
 //更新数据库schema 
 String databaseSchemaUpgrade(Connection connection, String catalog, String schema);
 
数据库管理代码示例
--------------------------------
 //获取数据表的名称及元数据
 String tableName = managementService
 .getTableName(HistoricProcessInstanceEntity.class); 
 
 System.out.println("HistoricProcessInstanceEntity对应的表名为：" + tableName);
 
 TableMetaData tableMetaData = managementService
 .getTableMetaData(tableName); 
 
 List<String> columnNames = tableMetaData
 .getColumnNames(); 
 for (String columnName : columnNames) { 
	System.out.println("--字段：" + columnName); 
 }
 
 //获取表的分页查询对象
 TablePage tablePage = managementService
 .createTablePageQuery() 
 .tableName(tableName) 
 .orderAsc("START_TIME_") 
 .listPage(1, 10); 
 
 System.out.println(tableName + "的记录数为：" + tablePage.getTotal());
 
异步任务管理
--------------------------------
ManagementService接口中关于异步任务管理的方法

 // 获取异步任务查询对象
 JobQuery createJobQuery(); 
 // 获取定时任务查询对象
 TimerJobQuery createTimerJobQuery(); 
 // 获取挂起任务查询对象
 SuspendedJobQuery createSuspendedJobQuery(); 
 // 获取不可执行任务查询对象
 DeadLetterJobQuery createDeadLetterJobQuery(); 
 // 强制执行任务
 void executeJob(String jobId); 
 // 将定时任务移入可执行任务
 Job moveTimerToExecutableJob(String jobId); 
 // 将任务移入不可执行任务
 Job moveJobToDeadLetterJob(String jobId); 
 // 将不可执行任务重新加入可执行任务
 Job moveDeadLetterJobToExecutableJob(String jobId, int retries); 
 // 删除异步任务
 void deleteJob(String jobId); 
 // 删除定时任务
 void deleteTimerJob(String jobId); 
 // 删除不可执行的任务
 void deleteDeadLetterJob(String jobId); 
 // 设置异步任务剩余重试次数
 void setJobRetries(String jobId, int retries); 
 // 设置定时任务剩余重试次数
 void setTimerJobRetries(String jobId, int retries); 
 // 获取异步任务异常栈
 String getJobExceptionStacktrace(String jobId); 
 // 获取定时任务异常栈
 String getTimerJobExceptionStacktrace(String jobId); 
 // 获取挂起任务异常栈
 String getSuspendedJobExceptionStacktrace(String jobId); 
 // 获取不可执行的任务异常栈
 String getDeadLetterJobExceptionStacktrace(String jobId);
 
 
代码示例
--------------------------------
 //查询第一个任务
 Task firstTask = taskService.createTaskQuery().processInstanceId( 
 processInstance.getId()).singleResult(); 
 //完成第一个任务
 taskService.complete(firstTask.getId()); 
 // 查询流程实例ID对应的job任务列表
 List<Job> timerJobs = managementService
 .createTimerJobQuery()
 .processInstanceId(processInstance.getId())
 .list();
 for (Job job : timerJobs) { 
	 System.out.println(
	 "定时任务" + job.getId() + 
	 "类型：" + job.getJobType() + 
	 "定时执行时间：" + dateFormat.format(job.getDuedate())); 
	 
	 managementService.moveTimerToExecutableJob(job.getId());
	 System.out.println("----立即执行任务" + job.getId()); 
	 managementService.executeJob(job.getId());
 }
 用ManagementService接口的createTimerJobQuery()方法查询定时任务
 用ManagementService()的moveTimerToExecutableJob()方法将定时任务移入执行任务列表
 用ManagementService的executeJob()方法立即执行该任务
 
 