RHCSA 属于 Linux 系统的初级认证
-----------------------------------
能够熟练使用 Linux 命令来完成以下任务
➢ 访问命令行；
➢ 使用命令行管理文件；
➢ 创建、查看和编辑文本文件；
➢ 管理本地用户和群组；
➢ 监控和管理 Linux 进程；
➢ 控制服务和守护进程；
➢ 利用文件系统权限控制文件访问；
➢ 分析和存储日志文件；
➢ 配置和确保 OpenSSH 服务的安全；
➢ 安装和更新软件包；
➢ 访问 Linux 文件系统；
➢ 管理 Linux 网络；
➢ 使用 Kickstart 安装红帽企业版 Linux；
➢ 管理文件系统和逻辑卷；
➢ 管理计划作业；
➢ 访问网络文件系统；
➢ 管理 SELinux；
➢ 控制防火墙；
➢ 执行故障排除任务；

RHCE 认证适合有基础的 Linux 运维管理员
-----------------------------------
中级水平认证 能够完成以下任务
➢ 在控制节点上安装和配置 Ansible 或红帽 Ansible 引擎；
➢ 创建和管理托管主机列表，并使它们为 Ansible 自动化做好准备；
➢ 通过命令行运行单个 ad hoc 自动化任务；
➢ 编写 Ansible playbook（剧本）以便自动执行多个任务，并将其应用于托管主机；
➢ 使用变量和 fact 对剧本进行参数化处理，并使用 Ansible vault 保护敏感数据；
➢ 编写和重用现有的 Ansible 角色，以简化剧本的创建并重用代码；
➢ 使用 Ansible 自动执行常见的红帽企业版 Linux 系统的管理任务。

RHCA 属于 Linux 系统的最高级别认证
-----------------------------------
红帽卫星服务
红帽系统集群
红帽虚拟化
系统性能调优
以及红帽云系统的安装搭建与维护能力

常用的 RPM 软件包命令
-----------------------------------
rpm –ivh filename.rpm 安装软件
rpm –Uvh filename.rpm 升级软件
rpm -e filename.rpm 卸载软件
rpm –qpi filename.rpm 查询软件描述信息
rpm -qpl filename.rpm 列出软件文件信息
rpm -qf filename 查询文件属于哪个 RPM

常见的 Yum 命令
-----------------------------------
yum repolist all 列出所有仓库
yum list all 列出仓库中所有软件包
yum info 软件包名称 查看软件包信息
yum install 软件包名称 安装软件包
yum reinstall 软件包名称 重新安装软件包
yum update 软件包名称 升级软件包
yum remove 软件包名称 移除软件包
yum clean all 清除所有仓库缓存
yum check-update 检查可更新的软件包
yum grouplist 查看系统中已经安装的软件包组
yum groupinstall 软件包组 安装指定的软件包组
yum groupremove 软件包组 移除指定的软件包组
yum groupinfo 软件包组 查询指定的软件包组信息

systemd 与 System V init 的区别以及作用
-----------------------------------
System V init |systemd 目标作用
0 | poweroff.target | 关机
1 | rescue.target | 单用户模式
2 | multi-user.target | 多用户的文本界面
3 | multi-user.target | 多用户的文本界面
4 | multi-user.target | 多用户的文本界面
5 | graphical.target | 多用户的图形界面
6 | reboot.target | 重启
emergency | emergency.target | 救援模式

服务的启动、重启、停止、重载、查看状态等常用命令
-----------------------------------
老系统命令 RHEL 5/6 系统
service foo start 启动服务
service foo restart 重启服务
service foo stop 停止服务
service foo reload 重新加载配置文件（不终止服务）
service foo status 查看服务状态

新系统命令 RHEL 7/8 系统
systemctl start httpd 启动服务
systemctl restart httpd 重启服务
systemctl stop httpd 停止服务
systemctl reload httpd 重新加载配置文件（不终止服务）
systemctl status httpd 查看服务状态

服务开机启动、不启动、查看各级别下服务启动状态等常用命令
-----------------------------------
老系统命令 RHEL 5/6 系统
chkconfig foo on 开机自动启动
chkconfig foo off 开机不自动启动
chkconfig foo 查看特定服务是否为开机自启动
chkconfig --list 查看各个级别下服务的启动与禁用情况

新系统命令 RHEL 7/8 系统
systemctl enable httpd 开机自动启动
systemctl disable httpd 开机不自动启动
systemctl is-enabled httpd 查看特定服务是否为开机自启动
systemctl list-unit-files --type=httpd 查看各个级别下服务的启动与禁用情况

重置 root 密码
-----------------------------------
要先确定是否为 RHEL 8 系统
1.重启Linux 系统主机并出现引导界面时，按下键盘上的 e 键进入内核编辑界面
2.在 linux 参数这行的最后面追加 rd.break 参数，然后按下 Ctrl + X 组合键运行修改过的内核程序
3.大约 30 秒过后，系统会进入紧急救援模式
4.然后依次输入以下命令
mount -o remount,rw /sysroot
chroot /sysroot
passwd
touch /.autorelabel
5.再连续按下两次 Ctrl + D 组合键盘来退出并重启

复习题
-----------------------------------
1．为什么建议读者在下载系统文件后先进行校验而不是直接安装呢？
为了保证系统和软件包的安全与完整性，避免因为外部因素导致安装失败—磨刀不误砍柴工。
2．使用虚拟机安装 Linux 系统时，为什么要先选择稍后安装操作系统，而不是去选择 RHEL 8 系统镜像文件？
在配置界面中若直接选择了 RHEL 8 系统镜像文件，则 VMware Workstation 虚拟机会
使用内置的安装向导自动进行安装，最终安装出来的系统跟我们后续进行实验所需的系统环境会不一样。
3．在安装系统时如果出现类似于“CPU 不支持虚拟化”这样的报错信息，该怎么解决？
遇到此类报错，最大的可能原因是 BIOS 中没有开启 VT 功能，手动开启后重启即可。
4．RPM（红帽软件包管理器）只有红帽企业系统在使用，对吗？
RPM 已经被 CentOS、Fedora、openSUSE 等众多 Linux 系统采用，它真的很好用！
5．简述 RPM 与软件仓库的作用。
RPM 是通过将源代码与安装规则打包在一起，降低了单个软件的安装难度。而 Yum
与 DNF 软件仓库则是将大量常用的 RPM 软件包打包到一起，解决了软件包之间的依
赖关系，这进一步降低了软件的整体安装难度。
6．RHEL 7/8 系统采用了 systemd 作为初始化进程，那么如何查看某个服务的运行状态呢？
执行命令“systemctl status 服务名”可以查看服务的运行状态。

-----------------------------------
新手必须掌握的 Linux 命令
-----------------------------------

➢ 强大好用的 Shell；
➢ 执行命令的必备知识；
➢ 常用系统工作命令；
➢ 系统状态检测命令；
➢ 查找定位文件命令；
➢ 文本文件编辑命令；
➢ 文件目录管理命令。

Linux 系统默认使用的终端是 Bash
-----------------------------------
➢ 通过上下方向键来调取执行过的 Linux 命令；
➢ 命令或参数仅需输入前几位就可以用 Tab 键补全；
➢ 具有强大的批处理脚本；
➢ 具有实用的环境变量功能。
Shell 就是终端程序的统称
Shell 与 Bash 是包含与被包含的关系是 Shell 终端程序中的一份子。

执行命令的必备知识
-----------------------------------
常见的执行 Linux 命令的格式是下面这样的。
命令名称 [命令参数] 命令对象

➢ ：就是语法中的“动词”，表达的是想要做的事情，
例如创建用户、查看文件、重启系统等操作。

➢ ：用于对命令进行调整，让“修改”过的命令能更好地贴合
工作需求，达到事半功倍的效果。

参数可以用长格式（完整的选项名称），
也可以用短格式（单个字母的缩写），
两者分别用“--”与“-”作为前缀

Linux 命令参数的长格式与短格式示例
-----------------------------------
长格式 man –-help
短格式 man -h

命令名称、命令参数与命令对象的区分
-----------------------------------
命令名称、命令参数与命令对象之间要用空格进行分隔，且字母严格区分大小写。

可选参数
-----------------------------------
在 Linux 相关的图书中，我们会约定俗成地将可选择的、可加或可不加的、非必需
的参数使用中括号引起来，例如“man [命令参数]”；

必有参数
-----------------------------------
而命令所要求的、必须有的参数或对象值，则不带中括号。
这样一来，读者可以更好地理解下面出现的命令格式。

man 命令中常用按键及其作用
-----------------------------------
空格键 向下翻一页
PaGe down 向下翻一页
PaGe up 向上翻一页
home 直接前往首页
end 直接前往尾页
/ 从上至下搜索某个关键词，如“/linux”
? 从下至上搜索某个关键词，如“?linux”
n 定位到下一个搜索到的关键词
N 定位到上一个搜索到的关键词
q 退出帮助文档

man 命令中帮助信息的结构及其代表意义
-----------------------------------
NAME 命令的名称
SYNOPSIS 参数的大致使用方法
DESCRIPTION 介绍说明
EXAMPLES 演示（附带简单说明）
OVERVIEW 概述
DEFAULTS 默认的功能
OPTIONS 具体的可用选项（带介绍）
ENVIRONMENT 环境变量
FILES 用到的文件
SEE ALSO 相关的资料
HISTORY 维护历史与联系方式

额外四个快捷键/组合键小技巧
-----------------------------------
➢ ：在 Bash 解释器的快捷键中，它能够实现对命令、参数或文件的内容补全

➢ ：当同时按下键盘上的 Ctrl 和字母 C 的时候，意味着终止当前进程的运行。

➢ ：当同时按下键盘上的 Ctrl 和字母 D 的时候，表示键盘输入结束。

➢ ：当同时按下键盘上行的 Ctrl 和字母 l 的时候，会清空当前终端中已有的内容
（相当于清屏操作）。

从现在开始，后面的内容都是重磅内容（意思是要背诵）
linux大约 150 个常用的Linux 命令，以及 50 多个热门的命令 
老师根据 10 多年来的运维经验优先筛选出了 10 多个高频使用的基础命令。

-----------------------------------
常用系统工作命令
-----------------------------------

1.echo 命令
-----------------------------------
echo 命令用于在终端设备上输出字符串或变量提取后的值，
语法格式为“echo [字符串] [$变量]”。

例如，把指定字符串“LinuxProbe.com”输出到终端屏幕的命令为：
[root@linuxprobe~]# echo LinuxProbe.com
该命令会在终端屏幕上显示如下信息：
LinuxProbe.com

下面使用“$变量”的方式提取出变量 SHELL 的值，并将其输出到屏幕上：
[root@linuxprobe~]# echo $SHELL
/bin/bash

2.date命令
-----------------------------------
date 命令用于显示或设置系统的时间与日期，语法格式为“date [+指定的格式]”。

用户只需在强大的 date 命令后输入以“+”号开头的参数，即可按照指定格式来输出系
统的时间或日期，这样在日常工作时便可以把备份数据的命令与指定格式输出的时间信息结
合到一起

date 命令中的参数及其作用
%S 秒（00～59）
%M 分钟（00～59）
%H 小时（00～23）

%I 小时（00～12）
%m 月份（1～12）
%p 显示出 AM 或 PM
%a 缩写的工作日名称（例如，Sun）
%A 完整的工作日名称（例如，Sunday）
%b 缩写的月份名称（例如，Jan）
%B 完整的月份名称（例如，January）
%q 季度（1～4）
%y 简写年份（例如，20）
%Y 完整年份（例如，2020）
%d 本月中的第几天
%j 今年中的第几天
%n 换行符（相当于按下回车键）
%t 跳格（相当于按下 Tab 键）


按照默认格式查看当前系统时间的 date 命令如下所示：
[root@linuxprobe~]# date
Sat Sep 5 09:13:45 CST 2020

按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的date 命令如下所示：
[root@linuxprobe~]# date "+%Y-%m-%d %H:%M:%S"
2020-09-05 09:14:35

将系统的当前时间设置为 2020 年 11 月 1 日 8 点 30 分的 date 命令如下所示：
[root@linuxprobe~]# date -s "20201101 8:30:00"
Sun Nov 1 08:30:00 CST 2020

再次使用 date 命令并按照默认的格式查看当前的系统时间，如下所示：
[root@linuxprobe~]# date
Sun Nov 1 08:30:08 CST 2020

date 命令中的参数%j 可用来查看今天是当年中的第几天。这个参数能够很好地区分备份
时间的早晚，即数字越大，越靠近当前时间。该参数的使用方式以及显示结果如下所示：
[root@linuxprobe~]# date "+%j"
306

3.timedatectl
-----------------------------------
timedatectl 命令用于设置系统的时间，英文全称为“time date control”，
语法格式为“timedatectl [参数]”。

status 显示状态信息
list-timezones 列出已知时区
set-time 设置系统时间
set-timezone 设置生效时区

查看系统时间与时区的方法如下：

[root@linuxprobe~]# timedatectl status
Local time: Sun 2020-09-06 19:51:22 CST
Universal time: Sun 2020-09-06 11:51:22 UTC
RTC time: Sun 2020-09-06 19:51:21
Time zone: Asia/Shanghai (CST, +0800)
System clock synchronized: no
NTP service: inactive
RTC in local TZ: no

如果您查到的时区不是上海（Asia/Shanghai），可以手动进行设置：
[root@linuxprobe~]# timedatectl set-timezone Asia/Shanghai

如果时间还是不正确，可再手动修改系统日期：
[root@linuxprobe~]# timedatectl set-time 2021-05-18

而如果想修改时间的话，也很简单：
[root@linuxprobe~]# timedatectl set-time 9:30
[root@linuxprobe~]# date
Tue May 18 09:30:01 CST 2021

4.rebot命令
-----------------------------------
reboot 命令用于重启系统，输入该命令后按回车键执行即可。

由于重启计算机这种操作会涉及硬件资源的管理权限，因此最好是以 root 管理员的身份
来重启，普通用户在执行该命令时可能会被拒绝。reboot 的命令如下：
[root@linuxprobe~]# reboot


5.poweroff命令
-----------------------------------
poweroff 命令用于关闭系统，输入该命令后按回车键执行即可。
与上面相同，该命令也会涉及硬件资源的管理权限，因此最好还是以 root 管理员的身份

来关闭电脑，其命令如下：
[root@linuxprobe~]# poweroff

6.wget命令
-----------------------------------
wget 命令用于在终端命令行中下载网络文件，英文全称为“web get”，
语法格式为“wget [参数] 网址”。

借助于 wget 命令，可以无须打开浏览器，直接在命令行界面中就能下载文件。
如果您没有 Linux 系统的管理经验，当前只需了解一下 wget 命令的参数以及作用，
然后看一眼下面的演示实验就够了，切记不要急于求成。
后面章节将逐步讲解 Linux 系统的配置管理方法，
可以等掌握了网卡的配置方法后再来进行这个实验操作

wget 命令中的参数以及作用：
-b 后台下载模式
-P 下载到指定目录
-t 最大尝试次数
-c 断点续传
-p 下载页面内所有资源，包括图片、视频等
-r 递归下载

执行该命令后的下载效果如下：

[root@linuxprobe~]# wget https://www.linuxprobe.com/docs/LinuxProbe.pdf
--2020-09-28 19:24:39-- https://www.linuxprobe.com/docs/LinuxProbe.pdf
Resolving www.linuxprobe.com (www.linuxprobe.com)... 221.15.64.1
Connecting to www.linuxprobe.com (www.linuxprobe.com)|221.15.64.1|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 17676281 (17M) [application/pdf]
Saving to: ‘LinuxProbe.pdf’
LinuxProbe.pdf 100%[============>] 16.86M 15.9MB/s in 1.1s
2020-09-28 19:24:40 (15.9 MB/s) - ‘LinuxProbe.pdf’saved [17676281/17676281]

接下来，使用 wget 命令递归下载 www.linuxprobe.com 网站内的所有页面数据以及文件，
下载完后会自动保存到当前路径下一个名为 www.linuxprobe.com 的目录中

[root@linuxprobe~]# wget -r -p https://www.linuxprobe.com
--2020-09-28 19:26:12-- https://www.linuxprobe.com/
Resolving www.linuxprobe.com (www.linuxprobe.com)... 221.15.64.1
Connecting to www.linuxprobe.com (www.linuxprobe.com)|221.15.64.1|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: ‘www.linuxprobe.com/index.html’
………………省略下载过程………………


7.ps命令
-----------------------------------
ps 命令用于查看系统中的进程状态，
英文全称为“processes”，语法格式为“ps [参数]”。

高手通常会将 ps 命令与第 3 章的管道符技术搭配使用，用来抓取与某个指
定服务进程相对应的 PID 号码

ps 命令中的参数以及作用：
-a 显示所有进程（包括其他用户的进程）
-u 用户以及其他详细信息
-x 显示没有控制终端的进程

 Linux 系统中有 5 种常见的进程状态，
 分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。
➢ R（运行）：进程正在运行或在运行队列中等待。
➢ S（中断）：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该 状态。
➢ D（不可中断）：进程不响应系统异步信号，即便用 kill 命令也不能将其中断。
➢ Z（僵死） ：进程已经终止，但进程描述符依然存在, 直到父进程调用 wait4()系统函数后将进程释放。
➢ T（停止）：进程收到停止信号后停止运行。

除了上面 5 种常见的进程状态，还有可能是高优先级（<）、低优先级（N）、被锁进内存
（L）、包含子进程（s）以及多线程（l）这 5 种补充形式。

当执行 ps aux 表头含义：
USER ：进程的所有者
PID ：进程ID 号
%CPU ：运算器占用率
%MEM ：内存占用率
VSZ ：虚拟内存使用量（单位是 KB）
RSS ：占用的固定内存量（单位是KB）
TTY ：所在终端
STAT ：进程状态
START ：被启动的时间
TIME ：实际使用 CPU的时间
COMMAND ：命令名称与参数

长格式段格式
-----------------------------------
1.长格式和长格式之
2.长格式和短格式之间也不能合并间不能合并
3.但短格式和短格式之间是可以合并的，合并后仅保留一个减号（-）即可
4.另外 ps 命令可允许参数不加减号（-），因此可直接写成 ps aux 的样子。

8.pstree
-----------------------------------
pstree 命令用于以树状图的形式展示进程之间的关系，
英文全称为“process tree”，输入该命令后按回车键执行即可

9.top命令
-----------------------------------
top 命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。

在图 2-6 中，top 命令执行结果的前 5 行为系统整体的统计信息，其所代表的含义如下。
➢ 第 1 行：系统时间、运行时间、登录终端数、系统负载（3 个数值分别为 1 分钟、5
分钟、15 分钟内的平均值，数值越小意味着负载越低）。
➢ 第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。
➢ 第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源
百分比、空闲的资源百分比等。其中数据均为 CPU 数据并以百分比格式显示，例如
“99.9 id”意味着有 99.9%的 CPU 处理器资源处于空闲。
➢ 第 4 行：物理内存总量、内存空闲量、内存使用量、作为内核缓存的内存量。
➢ 第 5 行：虚拟内存总量、虚拟内存空闲量、虚拟内存使用量、已被提前加载的内存量。

10.nice命令
-----------------------------------
nice 命令用于调整进程的优先级，语法格式为“nice 优先级数字 服务名称”。
在 top 命令输出的结果中，PR 和 NI 值代表的是进程的优先级，
数字越低（取值范围是-20～19），优先级越高。

例如将 bash 服务的优先级调整到最高：
[root@linuxprobe~]# nice -n -20 bash
[root@linuxprobe~]#

11.pidof
-----------------------------------
pidof 命令用于查询某个指定服务进程的 PID 号码值，
语法格式为“pidof [参数] 服务名称”。

每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。

查询本机上 sshd 服务程序的 PID：
[root@linuxprobe~]# pidof sshd
2156

12.kill命令
-----------------------------------
kill 命令用于终止某个指定 PID 值的服务进程，语法格式为“kill [参数] 进程的 PID”。
接下来，使用 kill 命令把上面用 pidof 命令查询到的 PID 所代表的进程终止掉，其命令如下所示。

这种操作的效果等同于强制停止 sshd 服务。
[root@linuxprobe~]# kill 2156
但有时系统会提示进程无法被终止，此时可以加参数-9，表示最高级别地强制杀死进程：
[root@linuxprobe~]# kill -9 2156

13.killall命令
-----------------------------------
killall 命令用于终止某个指定名称的服务所对应的全部进程，
语法格式为“killall [参数] 服务名称”。

通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果用 kill 命令逐
个去结束这些进程会比较麻烦，此时可以使用 killall 命令来批量结束某个服务程序带有的全部进程。

下面以 httpd 服务程序为例，来结束其全部进程：
[root@linuxprobe~]# pidof httpd
13581 13580 13579 13578 13577 13576
[root@linuxprobe~]# killall httpd
[root@linuxprobe~]# pidof httpd
[root@linuxprobe~]#

如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入
-----------------------------------
则可以在执行命令时在末尾添加一个&符号

-----------------------------------
系统状态检测命令
-----------------------------------

1.ifconfig命令
-----------------------------------
ifconfig 命令用于获取网卡配置与网络状态等信息，英文全称为“interface config”，
语法格式为“ifconfig [参数] [网络设备]”。

[root@linuxprobe~]# ifconfig
ens160: flags=4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500
inet 192.168.10.10 netmask 255.255.255.0 broadcast 192.168.10.255
inet6 fe80::c8f8:f5c5:8251:aeaa prefixlen 64 scopeid 0x20
ether 00:0c:29:7d:27:bf txqueuelen 1000 (Ethernet)
RX packets 304 bytes 33283 (32.5 KiB)
RX errors 0 dropped 0 overruns 0 frame 0
TX packets 91 bytes 11052 (10.7 KiB)
TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0
lo: flags=73<UP,LOOPBACK,RUNNING> mtu 65536
inet 127.0.0.1 netmask 255.0.0.0
inet6 ::1 prefixlen 128 scopeid 0x10
loop txqueuelen 1000 (Local Loopback)
RX packets 376 bytes 31784 (31.0 KiB)

2.uname命令
-----------------------------------
uname 命令用于查看系统内核版本与系统架构等信息，
英文全称为“unix name”，语法格式为“uname [-a]”。

在使用 uname 命令时，一般要固定搭配上-a 参数来完整地查看当前系统的
内核名称、
主机名、
内核发行版本、
节点名、
压制时间、
硬件名称、
硬件平台、
处理器类型
以及操作系统名称等信息：

[root@linuxprobe~]# uname -a
Linux linuxprobe.com 4.18.0-80.el8.x86_64 #1 SMP Wed Mar 13 12:02:46 UTC 2019
x86_64 x86_64 x86_64 GNU/Linux

顺带一提，如果要查看当前系统版本的详细信息，则需要查看 redhat-release 文件，其命
令以及相应的结果如下：

[root@linuxprobe~]# cat /etc/redhat-release
Red Hat Enterprise Linux release 8.0 (Ootpa)

3.uptime命令
-----------------------------------
uptime 命令用于查看系统的负载信息，输入该命令后按回车键执行即可。
uptime 命令真的很棒，它可以显示
当前系统时间、
系统已运行时间、
启用终端数量以及
平均负载值等信息。
平均负载值指的是系统在最近 1 分钟、5 分钟、15 分钟内的压力情况（下
面加粗的信息部分），负载值越低越好：

[root@linuxprobe~]# uptime
22:49:55 up 10 min, 1 users, load average: 0.01, 0.19, 0.18
“负载值越低越好”是对运维人员来讲的，越低表示越安全省心。但是公司购置
的硬件设备如果长期处于空闲状态，则明显是种资源浪费，老板也不会开心。所以建
议负载值保持在 1 左右，在生产环境中不要超过 5 就好。

4.free命令
-----------------------------------
free 命令用于显示当前系统中内存的使用量信息，语法格式为“free [-h]”。

[root@linuxprobe~]# free -h
     Total used free shared buffers buff/cache available
Mem： 1.9Gi 1.4Gi 99Mi 20Mi 450Mi 348Mi
Swap： 2.0Gi 80Mi 1.9Gi

Total：内存总量
used：已用量
free：空闲量
shared：进程功效的内存量
buffers：磁盘缓存的内存量
buff/cache：缓存的内存量
available：可用内存量

5.who命令
-----------------------------------
who 命令用于查看当前登入主机的用户终端信息，
输入该命令后按回车键执行即可。

6.last命令
-----------------------------------
last 命令用于调取主机的被访记录，输入该命令后按回车键执行即可。

7.ping命令
-----------------------------------
ping 命令用于测试主机之间的网络连通性，语法格式为“ping [参数] 主机地址”。

ping 命令中的参数以及作用
-c 总共发送次数
-l 指定网卡名称
-I 每次间隔时间（秒）
-W 最长等待时间（秒）

我们使用 ping 命令测试一台在线的主机
[root@linuxprobe~]# ping -c 4 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.155 ms
64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.110 ms
64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.112 ms
64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.209 ms
--- 192.168.10.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 56ms
rtt min/avg/max/mdev = 0.110/0.146/0.209/0.042 ms

测试一台不在线的主机
[root@linuxprobe~]# ping -c 4 192.168.10.20
PING 192.168.10.20 (192.168.10.20) 56(84) bytes of data.
From 192.168.10.10 icmp_seq=1 Destination Host Unreachable
From 192.168.10.10 icmp_seq=2 Destination Host Unreachable
From 192.168.10.10 icmp_seq=3 Destination Host Unreachable
From 192.168.10.10 icmp_seq=4 Destination Host Unreachable
--- 192.168.10.20 ping statistics ---
4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 68ms
pipe 4

8.tracepath
-----------------------------------
tracepath 命令用于显示数据包到达目的主机时途中经过的所有路由信息，
语法格式为“tracepath [参数] 域名”。

当两台主机之间无法正常 ping 通时，要考虑两台主机之间是否有错误的路由信息，
导致数据被某一台设备错误地丢弃

。这时便可以使用 tracepath 命令追踪数据包到达目的主机时途
中的所有路由信息，以分析是哪台设备出了问题。下面的情况就很清晰了

9.netsatt命令
-----------------------------------
netstat 命令用于显示如网络连接、路由表、接口状态等的网络相关信息，
英文全称为“network status”，语法格式为“netstat [参数]”

netstat 命令中的参数以及作用：
-a 显示所有连接中的 Socket
-p 显示正在使用的 Socket 信息
-t 显示 TCP 协议的连接状态
-u 显示 UDP 协议的连接状态

-n 使用 IP 地址，不使用域名
-l 仅列出正在监听的服务状态
-i 现在网卡列表信息
-r 显示路由表信息

10.history命令
-----------------------------------
history 命令用于显示执行过的命令历史，语法格式为“history [-c]”。

历史命令会被保存到用户家目录中的.bash_history 文件中。Linux 系统中以点（.）开头的
文件均代表隐藏文件，这些文件大多数为系统服务文件，可以用 cat 命令查看其文件内容：
[root@linuxprobe~]# cat ~/.bash_history

要清空当前用户在本机上执行的 Linux 命令历史记录信息，可执行如下命令：
[root@linuxprobe~]# history -c

11.sosreport 命令
-----------------------------------
sosreport 命令用于收集系统配置及架构信息并输出诊断文档，输入该命令后按回车键执行即可。

sosreport 命令有点像是远程问诊。假如我们今天有点咳嗽发烧不舒服，可以先从
网上搜索相关症状的病因，如果仅仅是感冒的话那就多喝水，这就免去了到医院挂号
看病的车马劳顿；而如果怀疑出了大毛病，再请专业人员进行处理也不迟。

-----------------------------------
查找定位文件命令
-----------------------------------

1.pwd命令
-----------------------------------
pwd 命令用于显示用户当前所处的工作目录，
英文全称为“print working directory”，输入该命令后按回车键执行即可。

[root@linuxprobe etc]# pwd
/etc

2.cd命令
-----------------------------------
cdcd 命令用于切换当前的工作路径，英文全称为“change directory”，
语法格式为“cd [参数] [目录]”。

这个命令应该是最常用的一个 Linux 命令了
“cd -”命令返回到上一次所处的目录
“cd..”命令进入上级目录
“cd～username”命令切换到其他用户的家目录

例如，使用下述的 cd 命令切换进/etc 目录中：
[root@linuxprobe~]# cd /etc

同样的道理，可使用下述命令切换到/bin 目录中：
[root@linuxprobe etc]# cd /bin

此时，要返回到上一次的目录（即/etc 目录），可执行如下命令：
[root@linuxprobe bin]# cd -
/etc
[root@linuxprobe etc]#

还可以通过下面的命令快速切换到用户的家目录：
[root@linuxprobe etc]# cd~
[root@linuxprobe~]#

3.ls命令
-----------------------------------
ls 命令用于显示目录中的文件信息，
英文全称为“list”，语法格式为“ls [参数] [文件名称]”。

使用 ls 命令的-a 参数可以看到全部文件（包括隐藏文件），
使用-l 参数可以查看文件的属性、大小等详细信息。
[root@linuxprobe~]# ls -al
total 48
dr-xr-x---. 15 root root 4096 Jul 24 06:33 .
dr-xr-xr-x. 17 root root 224 Jul 21 05:04 ..
-rw-------. 1 root root 1407 Jul 21 05:09 anaconda-ks.cfg
-rw-------. 1 root root 335 Jul 24 06:33 .bash_history
-rw-r--r--. 1 root root 18 Aug 13 2018 .bash_logout
-rw-r--r--. 1 root root 176 Aug 13 2018 .bash_profile
-rw-r--r--. 1 root root 176 Aug 13 2018 .bashrc
drwx------. 10 root root 230 Jul 21 05:19 .cache
drwx------. 11 root root 215 Jul 24 06:27 .config
-rw-r--r--. 1 root root 100 Aug 13 2018 .cshrc
drwx------. 3 root root 25 Jul 21 05:16 .dbus
drwxr-xr-x. 2 root root 6 Jul 21 05:19 Desktop

如果想要查看目录属性信息，则需要额外添加一个-d 参数
/etc 目录的权限与属性信息：

[root@linuxprobe~]# ls -ld /etc
drwxr-xr-x. 132 root root 8192 Jul 10 10:48 /etc

4.tree命令
-----------------------------------
tree 命令用于以树状图的形式列出目录内容及结构，输入该命令后按回车键执行即可。

我们来对比一下两者的区别。
使用 ls 命令查看目录内的文件：
[root@linuxprobe~]# ls
A Desktop Downloads Music Public Videos
anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures Templates

使用 tree 命令查看目录内文件名称以及结构：
[root@linuxprobe~]# tree
.
├──A
│ └──B
│ └──C
├──anaconda-ks.cfg
├──Desktop
├──Documents
├──Downloads
├──initial-setup-ks.cfg
├──Music
├──Pictures

5.find命令
-----------------------------------
find 命令用于按照指定条件来查找文件所对应的位置，
语法格式为“find [查找范围] 寻找条件”。

find 命令中的参数以及作用
-name 匹配名称
-perm 匹配权限（mode 为完全匹配，-mode 为包含即可）
-user 匹配所有者
-group 匹配所属组
-mtime -n +n 匹配修改内容的时间（-n 指 n 天以内，+n 指 n 天以前）
-atime -n +n 匹配访问文件的时间（-n 指 n 天以内，+n 指 n 天以前）
-ctime -n +n 匹配修改文件权限的时间（-n 指 n 天以内，+n 指 n 天以前）
-nouser 匹配无所有者的文件
-nogroup 匹配无所属组的文件
-newer f1 !f2 匹配比文件 f1 新但比 f2 旧的文件
--type b/d/c/p/l/f 匹配文件类型
（后面的字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）
-size 匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）
-prune 忽略某个目录
-exec…… {}\; 后面可跟用于进一步处理搜索结果的命令（下文会有演示）



如果要想获取该目录中所有以 host 开头的文件列表，可以执行如下命令：

[root@linuxprobe~]# find /etc -name "host*"
/etc/host.conf
/etc/hosts
/etc/hosts.allow
/etc/hosts.deny
/etc/avahi/hosts
/etc/hostname

如果要在整个系统中搜索权限中包括 SUID 
权限的所有文件（详见第 5 章），只需使用-4000 即可：

[root@linuxprobe~]# find / -perm -4000 -print
/usr/bin/fusermount
/usr/bin/chage
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/umount
/usr/bin/mount
/usr/bin/su
/usr/bin/pkexec
/usr/bin/crontab
/usr/bin/passwd
………………省略部分输出信息………………

6.locate命令
-----------------------------------
locate 命令用于按照名称快速搜索文件所对应的位置，
语法格式为“locate 文件名称”。

第一次使用locate 命令之前，记得先执行updatedb 命令来生成索引数据库，然后再进行查找：

[root@linuxprobe~]# updatedb
[root@linuxprobe~]# ls -l /var/lib/mlocate/mlocate.db
-rw-r-----. 1 root slocate 295917 Sep 13 17:54 /var/lib/mlocate/mlocate.db

使用 locate 命令搜索出所有包含“whereis”名称的文件所在的位置：

[root@linuxprobe~]# locate whereis
/usr/bin/whereis
/usr/share/bash-completion/completions/whereis
/usr/share/man/man1/whereis.1.gz

7.whereis 命令
-----------------------------------
whereis 命令用于按照名称快速搜索二进制程序（命令）、源代码以及帮助文件所对应的位置，
语法格式为“whereis 命令名称”。

whereis 命令也是基于 updatedb 命令所生成的索引库文件进行搜索，

它与 locate命令的区别是不关心那些相同名称的文件，仅仅是快速找到对应的命令文件及其帮助文件所
在的位置。

下面使用 whereis 命令分别查找出 ls 和 pwd 命令所在的位置：
[root@linuxprobe~]# whereis ls
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz
[root@linuxprobe~]# whereis pwd
pwd: /usr/bin/pwd /usr/share/man/man1/pwd.1.gz /usr/share/man/man1p/pwd.1p.gz

8.which命令
-----------------------------------
which 命令用于按照指定名称快速搜索二进制程序（命令）所对应的位置，
语法格式为“which 命令名称”。

which 命令是在 PATH 变量所指定的路径中，按照指定条件搜索命令所在的路径。
也就是说，如果我们既不关心同名文件（find 与 locate）
也不关心命令所对应的源代码和帮助文件（whereis）
仅仅是想找到命令本身所在的路径

[root@linuxprobe~]# which locate
/usr/bin/locate
[root@linuxprobe~]# which whereis
/usr/bin/whereis

-----------------------------------
文本文件编辑命令
-----------------------------------

1.cat命令
-----------------------------------
cat 命令用于查看纯文本文件（内容较少的），
英文全称为“concatenate”，语法格式为“cat [参数] 文件名称”。

如果在查看文本内容时还想顺便显示行号的话，不妨在 cat 命令后面追加一个-n 参数：
[root@linuxprobe~]# cat -n initial-setup-ks.cfg
1 #version=RHEL8
2 # X Window System configuration information
3 xconfig --startxonboot
4 # License agreement
5 eula --agreed
6 # Use graphical install
7 graphical
8 # Network information
9 network --bootproto=dhcp --device=ens160 --onboot=off --ipv6=auto --
no-activate
10 network --bootproto=dhcp --hostname=localhost.localdomain
11 repo --name="AppStream" --baseurl=file:///run/install/repo/AppStream
12 ignoredisk --only-use=sda
13 # Use CDROM installation media
14 cdrom
15 # Run the Setup Agent on first boot
16 firstboot --enable
17 # System services
………………省略部分输出信息………………

2.more命令
-----------------------------------
more 命令用于查看纯文本文件（内容较多的），语法格式为“more [参数] 文件名称”。

还可以使用空格键或回车键向下翻页

[root@linuxprobe~]# more initial-setup-ks.cfg
#version=RHEL8
# X Window System configuration information
xconfig --startxonboot
# License agreement
eula --agreed
# Use graphical install
graphical

3.head 命令
-----------------------------------
head 命令用于查看纯文本文件的前 N 行，语法格式为“head [参数] 文件名称”。
如果只想查看文本中前 10 行的内容，该怎么办呢？
head 命令就能派上用场了：

[root@linuxprobe~]# head -n 10 initial-setup-ks.cfg
#version=RHEL8
# X Window System configuration information
xconfig --startxonboot
# License agreement
eula --agreed
# Use graphical install
graphical
# Network information
network --bootproto=dhcp --device=ens160 --onboot=off --ipv6=auto --no-activate
network --bootproto=dhcp --hostname=localhost.localdomain

4.tail 命令
-----------------------------------
tail 命令用于查看纯文本文件的后 N 行或持续刷新文件的最新内容，
语法格式为“tail [参数] 文件名称”。

tail 命令的操作方法与 head 命令非常相似，
只需要执行“tail -n 20 文件名称”命令就可以达到这样的效果

[root@linuxprobe~]# tail -n 10 initial-setup-ks.cfg
%addon com_redhat_subscription_manager
%end
%addon ADDON_placeholder --disable --reserve-mb=auto
%end
%anaconda
pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty
pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok
pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty
%end

tail 命令最强悍的功能是能够持续刷新一个文件的内容
当想要实时查看最新的日志文件时
这特别有用，此时的命令格式为“tail -f 文件名称”：

[root@linuxprobe~]# tail -f /var/log/messages
Sep 15 00:14:01 localhost rsyslogd[1392]: imjournal: sd_journal_get_cursor()
failed: Cannot assign requested address [v8.37.0-9.el8]
Sep 15 00:14:01 localhost rsyslogd[1392]: imjournal: journal reloaded...
[v8.37.0-9.el8 try http://www.rsyslog.com/e/0 ]
Sep 15 00:14:01 localhost systemd[1]: Started update of the root trust anchor
for DNSSEC validation in unbound.
Sep 15 00:14:01 localhost sssd[kcm][2764]: Shutting down
Sep 15 00:14:06 localhost systemd[1]: Starting SSSD Kerberos Cache Manager...
Sep 15 00:14:06 localhost systemd[1]: Started SSSD Kerberos Cache Manager.
Sep 15 00:14:06 localhost sssd[kcm][3989]: Starting up

5.tr 命令
-----------------------------------
tr 命令用于替换文本内容中的字符，英文全称为“translate”，
语法格式为“tr [原始字符] [目标字符]”。

例如，把某个文本内容中的英文全部替换为大写：

[root@linuxprobe~]# cat anaconda-ks.cfg | tr [a-z] [A-Z]
#VERSION=RHEL8
IGNOREDISK --ONLY-USE=SDA
AUTOPART --TYPE=LVM
# PARTITION CLEARING INFORMATION
CLEARPART --ALL --INITLABEL --DRIVES=SDA
# USE GRAPHICAL INSTALL
GRAPHICAL
REPO --NAME="APPSTREAM" --BASEURL=FILE:///RUN/INSTALL/REPO/APPSTREAM

6.wc 命令
-----------------------------------
wc 命令用于统计指定文本文件的行数、字数或字节数，
英文全称为“word counts”，语法格式为“wc [参数] 文件名称”。

wc 命令中的参数以及作用：
-l 只显示行数
-w 只显示单词数
-c 只显示字节数

[root@linuxprobe~]# wc -l /etc/passwd
45 /etc/passwd

7.stat 命令
-----------------------------------
stat 命令用于查看文件的具体存储细节和时间等信息，
英文全称为“status”，语法格式为“stat 文件名称”。

 Access Time（内容最后一次被访问的时间，简称为 Atime）
 Modify Time（内容最后一次被修改的时间，简称为 Mtime）
 Change Time（文件属性最后一次被修改的时间，简称为 Ctime）
 
下面使用 state 命令查看文件的这 3 种时间状态信息：

[root@linuxprobe ~]# stat anaconda-ks.cfg
File: anaconda-ks.cfg
Size: 1407 Blocks: 8 IO Block: 4096 regular file
Device: fd00h/64768d Inode: 35321091 Links: 1
Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)
Context: system_u:object_r:admin_home_t:s0
Access: 2020-07-21 05:16:52.347279499 +0800
Modify: 2020-07-21 05:09:16.421009316 +0800
Change: 2020-07-21 05:09:16.421009316 +0800
Birth: -

8.grep命令
-----------------------------------
grep 命令用于按行提取文本内容，语法格式为“grep [参数] 文件名称”。

两个最常用的参数：
➢ -n 参数用来显示搜索到的信息的行号；
➢ -v 参数用于反选信息（即没有包含关键词的所有信息行）

grep 命令中的参数及其作用：
-b 将可执行文件（binary）当作文本文件（text）来搜索
-c 仅显示找到的行数
-I 忽略大小写
-n 显示行号
-v 反向选择—仅列出没有“关键词”的行

[root@linuxprobe~]# grep /sbin/nologin /etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
………………省略部分输出过程信息………………

9.cut命令
-----------------------------------
cut 命令用于按“列”提取文本内容，语法格式为“cut [参数] 文件名称”。

系统文件在保存用户数据信息时，每一项值之间是采用冒号来间隔的，先查看一下：
[root@linuxprobe~]# head -n 2 /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin

接下来使用下述命令尝试提取出 passwd 文件中的用户名信息，即提取以冒号（：）为间
隔符号的第一列内容：

[root@linuxprobe~]# cut -d : -f 1 /etc/passwd
root
bin
daemon
adm
lp
sync
shutdown
halt
mail
operator
games
ftp
nobody
dbus
………………省略部分输出信息………………

10.diff命令
-----------------------------------
diff 命令用于比较多个文件之间内容的差异，英文全称为“different”，
语法格式为“diff [参数] 文件名称 A 文件名称 B”。

先使用 cat 命令分别查看 diff_A.txt 和 diff_B.txt 文件的内容，然后进行比较：
[root@linuxprobe~]# cat diff_A.txt
Welcome to linuxprobe.com
Red Hat certified
Free Linux Lessons
Professional guidance
Linux Course
[root@linuxprobe~]# cat diff_B.txt
Welcome tooo linuxprobe.com
Red Hat certified
Free Linux LeSSonS
////////.....////////
Professional guidance
Linux Course

接下来使用 diff --brief 命令显示比较后的结果，判断文件是否相同：
[root@linuxprobe~]# diff --brief diff_A.txt diff_B.txt
Files diff_A.txt and diff_B.txt differ

最后使用带有-c 参数的 diff 命令来描述文件内容具体的不同：
[root@linuxprobe~]# diff -c diff_A.txt diff_B.txt
*** diff_A.txt 2020-08-30 18:07:45.230864626 +0800
--- diff_B.txt 2020-08-30 18:08:52.203860389 +0800
***************
*** 1,5 ****
! Welcome to linuxprobe.com
Red Hat certified
! Free Linux Lessons
Professional guidance
Linux Course
--- 1,7 ----
! Welcome tooo linuxprobe.com
!
Red Hat certified
! Free Linux LeSSonS
! ////////.....////////
Professional guidance
Linux Course

11.uniq 命令
-----------------------------------
uniq 命令用于去除文本中连续的重复行，英文全称为“unique”，
语法格式为“uniq [参数] 文件名称”。

由 uniq 命令的英文全称 unique（独特的，唯一的）可知，该命令的作用是用来去除文本
文件中连续的重复行，中间不能夹杂其他文本行（非相邻的默认不会去重）

[root@linuxprobe~]# cat uniq.txt
Welcome to linuxprobe.com
Welcome to linuxprobe.com
Welcome to linuxprobe.com
Welcome to linuxprobe.com
Red Hat certified
Free Linux Lessons
Professional guidance
Linux Course

[root@linuxprobe~]# uniq uniq.txt
Welcome to linuxprobe.com
Red Hat certified
Free Linux Lessons
Professional guidance
Linux Course

12.sort 命令
-----------------------------------
sort 命令用于对文本内容进行再排序，语法格式为“sort [参数] 文件名称”。

sort 命令中的参数及其作用：
-f 忽略大小写
-b 忽略缩进与空格
-n 以数值型排序
-r 反向排序
-u 去除重复行
-t 指定间隔符
-k 设置字段范围

首先，在执行 sort 命令后默认会按照字母顺序进行排序，非常方便：
[root@linuxprobe~]# cat fruit.txt
banana
pear
apple
orange
raspaberry

[root@linuxprobe~]# sort fruit.txt
apple
banana
orange
pear
raspaberry

此外，与 uniq 命令不同，sort 命令是无论内容行之间是否夹杂有其他内容，只要有两个
一模一样的内容行，立马就可以使用-u 参数进行去重操作：

[root@linuxprobe~]# cat sort.txt
Welcome to linuxprobe.com
Red Hat certified
Welcome to linuxprobe.com
Free Linux Lessons
Linux Course
[root@linuxprobe~]# sort -u sort.txt
Free Linux Lessons
Red Hat certified
Welcome to linuxprobe.com

-----------------------------------
文件目录管理命令
-----------------------------------

1.touch 命令
-----------------------------------
touch 命令用于创建空白文件或设置文件的时间，
语法格式为“touch [参数] 文件名称”。

touch 命令中的参数及其作用
-a 仅修改“访问时间”（Atime）
-m 仅修改“修改时间”（Mtime）
-d 同时修改Atime与Mtime

接下来，先使用 ls 命令查看一个文件的修改时间，随后修改这个文件，最后再查看一下
文件的修改时间，看是否发生了变化：
[root@linuxprobe~]# ls -l anaconda-ks.cfg
-rw-------. 1 root root 1213 May 4 15:44 anaconda-ks.cfg
[root@linuxprobe~]# echo "Visit the LinuxProbe.com to learn linux skills" >> anaconda-ks.cfg
[root@linuxprobe~]# ls -l anaconda-ks.cfg
-rw-------. 1 root root 1260 Aug 2 01:26 anaconda-ks.cfg

如果不想让别人知道我们修改了它，那么这时就可以用 touch 命令把修改后的文件时间
设置成修改之前的时间（很多黑客就是这样做的呢）

[root@linuxprobe~]# touch -d "2020-05-04 15:44" anaconda-ks.cfg
[root@linuxprobe~]# ls -l anaconda-ks.cfg
-rw-------. 1 root root 1260 May 4 15:44 anaconda-ks.cfg

2.mkdir 命令
-----------------------------------
mkdir 命令用于创建空白的目录，英文全称为“make directory”，
语法格式为“mkdir [参数] 目录名称”。

[root@linuxprobe~]# mkdir linuxprobe
[root@linuxprobe~]# cd linuxprobe
[root@linuxprobe linuxprobe]# mkdir -p a/b/c/d/e
[root@linuxprobe linuxprobe]# cd a
[root@linuxprobe a]# cd b
[root@linuxprobe b]#

3.cp命令
-----------------------------------
cp 命令用于复制文件或目录，英文全称为“copy”，
语法格式为“cp [参数] 源文件名称 目标文件名称”。

➢ 如果目标文件是目录，则会把源文件复制到该目录中；
➢ 如果目标文件也是普通文件，则会询问是否要覆盖它；
➢ 如果目标文件不存在，则执行正常的复制操作。

复制命令基本不会出错，唯一需要记住的就是在复制目录时要加上-r 参数

cp 命令中的参数及其作用：
-p 保留原始文件的属性
-d 若对象为“链接文件”，则保留该“链接文件”的属性
-r 递归持续复制（用于目录）
-i 若目标文件存在则询问是否覆盖
-a 相当于-pdr（p、d、r 为上述参数）

接下来，使用 touch 命令创建一个名为 install.log 的普通空白文件，然后将其复制为一份

名为 x.log 的备份文件，最后再使用 ls 命令查看目录中的文件：
[root@linuxprobe~]# touch install.log
[root@linuxprobe~]# cp install.log x.log
[root@linuxprobe~]# ls
install.log x.log

4.mv命令
-----------------------------------
mv 命令用于剪切或重命名文件，英文全称为“move”，
语法格式为“mv [参数] 源文件名称 目标文件名称”。

剪切操作不同于复制操作，因为它默认会把源文件删除，只保留剪切后的文件。如果
在同一个目录中将某个文件剪切后还粘贴到当前目录下，其实也就是对该文件进行了重命
名操作
[root@linuxprobe~]# mv x.log linux.log
[root@linuxprobe~]# ls
install.log linux.log

5.rm命令
-----------------------------------
rm 命令用于删除文件或目录，英文全称为“remove”，
语法格式为“rm [参数] 文件 名称”。

如果不想总是看到这种反复的确认信息，
可在 rm 命令后跟上-f 参数来强制删除。

rm 命令中的参数及其作用：
-f 强制执行
-i 删除前询问
-r 删除目录
-v 显示过程

下面尝试删除前面创建的 install.log 和 linux.log 文件，
大家感受一下加与不加-f 参数的区别：
[root@linuxprobe~]# rm install.log
rm: remove regular empty file‘install.log’? y
[root@linuxprobe~]# rm -f linux.log
[root@linuxprobe~]# ls
[root@linuxprobe~]#

6.dd命令
-----------------------------------
dd 命令用于按照指定大小和个数的数据块来复制文件或转换文件，
语法格式为“dd if=参数值 of=参数值 count=参数值 bs=参数值”。

dd 命令中的参数及其作用：
if 输入的文件名称
of 输出的文件名称
bs 设置每个“块”的大小
count 设置要复制“块”的个数

Linux系统中有一个名为/dev/zero 的设备文件，
每次在课堂上解释它时都充满哲学理论的色彩。

例如，用 dd 命令从/dev/zero 设备文件中取出一个大小为 560MB 的数据块，然后保存成
名为 560_file 的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：

[root@linuxprobe~]# dd if=/dev/zero of=560_file count=1 bs=560M
1+0 records in
1+0 records out
587202560 bytes (587 MB, 560 MiB) copied, 1.28667 s, 456 MB/s

但在 Linux 系统中可以直接使用 dd 命令来压制出光盘镜像文件，
将它变成一个可立即使用的 iso 镜像
[root@linuxprobe~]# dd if=/dev/cdrom of=RHEL-server-8.0-x86_64-LinuxProbe.Com.iso
13873152+0 records in
13873152+0 records out
7103053824 bytes (7.1 GB, 6.6 GiB) copied, 27.8812 s, 255 MB/s

7.file命令
-----------------------------------
file 命令用于查看文件的类型，语法格式为“file 文件名称”。

在 Linux 系统中，由于文本、目录、设备等所有这些一切都统称为文件，但是它们又不
像 Windows 系统那样都有后缀，因此很难通过文件名一眼判断出具体的文件类型，这时就需
要使用 file 命令来查看文件类型了。
[root@linuxprobe~]# file anaconda-ks.cfg
anaconda-ks.cfg: ASCII text
[root@linuxprobe~]# file /dev/sda
/dev/sda: block special

8.tar命令
-----------------------------------
tar 命令用于对文件进行打包压缩或解压，语法格式为“tar 参数 文件名称”。

tar 命令中的参数及其作用
在 Linux 系统中，主要使用的是.tar、.tar.gz 或.tar.bz2
格式，大家不用担心格式太多而记不住，其实这些格式大部分都是由 tar 命令生成的。

tar 命令中的参数及其作用：
-c 创建压缩文件
-x 解开压缩文件
-t 查看压缩包内有哪些文件
-z 用 gzip 压缩或解压
-j 用 bzip2 压缩或解压
-v 显示压缩或解压的过程
-f 目标文件名
-p 保留原始的权限与属性
-P 使用绝对路径来压缩
-C 指定解压到的目录

[root@linuxprobe~]# tar czvf etc.tar.gz /etc
tar: Removing leading `/' from member names
/etc/
/etc/fstab
/etc/crypttab
/etc/mtab
/etc/fonts/
/etc/fonts/conf.d/
/etc/fonts/conf.d/65-0-madan.conf
/etc/fonts/conf.d/59-liberation-sans.conf
/etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf
/etc/fonts/conf.d/59-liberation-mono.conf
/etc/fonts/conf.d/66-sil-nuosu.conf
………………省略部分压缩过程信息………………

接下来将打包后的压缩包文件指定解压到/root/etc 目录中
（先使用 mkdir 命令创建/root/etc目录）：
[root@linuxprobe~]# mkdir /root/etc
[root@linuxprobe~]# tar xzvf etc.tar.gz -C /root/etc
etc/
etc/fstab
etc/crypttab
etc/mtab
etc/fonts/
etc/fonts/conf.d/


-----------------------------------
管道符、重定向与环境变量
-----------------------------------
本章讲解了如下内容：
➢ 输入输出重定向；
➢ 管道命令符；
➢ 命令行的通配符；
➢ 常用的转义字符；
➢ 重要的环境变量。

➢ 输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或
命令中输入。

➢ 输出重定向（STDOUT，文件描述为1）：默认输出到屏幕。

➢ 错误输出重定向（STDERR，文件描述符2）：默认输出到屏幕。）：默认输出到屏幕。

1.文件正常输出信息
2.错误输出信息
要想把原本输出到屏幕上的数据转而写入到文件当中，就要区别对待这两种输出信息。

输入重定向中用到的符号及其作用：
命令 < 文件 将文件作为命令的标准输入
命令 << 分界符 从标准输入中读入，直到遇见分界符才停止
命令 < 文件 1 > 文件 2 将文件 1 作为命令的标准输入并将标准输出到文件 2

对于输出重定向来讲：
命令 > 文件 将标准输出重定向到一个文件中（清空原有文件的数据）
命令 2> 文件 将错误输出重定向到一个文件中（清空原有文件的数据）
命令 >> 文件 将标准输出重定向到一个文件中（追加到原有内容的后面）
命令 2>> 文件 将错误输出重定向到一个文件中（追加到原有内容的后面）

命令 >> 文件 2>&1 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）

命令 &>> 文件 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面

对于重定向中的标准输出模式，可以省略文件描述符 1 不写
而错误输出模式的文件描述符 2 是必须要写的


[root@linuxprobe~]# man bash > readme.txt
[root@linuxprobe~]# cat readme.txt
BASH(1) General Commands Manual BASH(1)
NAME
bash - GNU Bourne-Again SHell



输入重定向相对来说有些冷门
[root@linuxprobe~]# wc -l < readme.txt
2

管道命令符 |
-----------------------------------
把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入

➢ 找出被限制登录用户的命令是 grep /sbin/nologin /etc/passwd；
➢ 统计文本行数的命令则是 wc–l。

[root@linuxprobe~]# grep /sbin/nologin /etc/passwd | wc -l
40

命令行的通配符 
-----------------------------------
通配符就是通用的匹配信息的符号
星号（*）代表匹配零个或多个字符
问号（?）代表匹配单个字符
中括号内加上数字[0-9]代表匹配 0～9 之间的单个数字的字符

Linux 系统中的通配符及含义：
* 任意字符
? 单个任意字符
[a-z] 单个小写字母
[A-Z] 单个大写字母
[a-Z] 单个字母
[0-9] 单个数字
[[:alpha:]] 任意字母
[[:upper:]] 任意大写字母
[[:lower:]] 任意小写字母
[[:digit:]] 所有数字
[[:alnum:]] 任意字母加数字
[[:punct:]] 标点符号

下面我们就来匹配所有在/dev 目录中且以 sda开头的文件：
[root@linuxprobe~]# ls -l /dev/sda*
brw-rw----. 1 root disk 8, 0 May 4 15:55 /dev/sda
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2


在/dev 目录中且以 sda开头的文件：
[root@linuxprobe~]# ls -l /dev/sda*
brw-rw----. 1 root disk 8, 0 May 4 15:55 /dev/sda
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2

后面紧跟某一个字符的文件：
[root@linuxprobe~]# ls -l /dev/sda?
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2

除了使用[0-9]来匹配 0～9 之间的单个数字：
[root@linuxprobe~]# ls -l /dev/sda[0-9]
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1
brw-rw----. 1 root disk 8, 2 May 4 15:55 /dev/sda2
[root@linuxprobe~]# ls -l /dev/sda[135]
brw-rw----. 1 root disk 8, 1 May 4 15:55 /dev/sda1

创建文件的命令相结合，创建多个文件时，需要使用大括号：
[root@linuxprobe~]# touch {AA,BB,CC}.conf
[root@linuxprobe~]# ls -l *.conf
-rw-r--r--. 1 root root 0 Sep 22 01:54 AA.conf
-rw-r--r--. 1 root root 0 Sep 22 01:54 BB.conf
-rw-r--r--. 1 root root 0 Sep 22 01:54 CC.conf

[root@linuxprobe~]# echo file{1,2,3,4,5}
file1 file2 file3 file4 file5

常用的转义字符
-----------------------------------
4 个最常用的转义字符如下所示

➢ 反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符。
➢ 单引号（''）：转义其中所有的变量为单纯的字符串。
➢ 双引号（""）：保留其中的变量属性，不进行转义处理。
➢ 反引号（``）：把其中的命令执行后返回结果。

我们先定义一个名为 PRICE 的变量并赋值为 5，
然后输出以双引号括起来的字符串与变量信息：
[root@linuxprobe~]# PRICE=5
[root@linuxprobe~]# echo "Price is $PRICE"
Price is 5

$$作用是显示当前程序的进程 ID 号码
[root@linuxprobe~]# echo "Price is $$PRICE"
Price is 3767PRICE

要使用反斜杠（\）来进行转义:
[root@linuxprobe~]# echo "Price is \$$PRICE"
Price is $5

需要某个命令的输出值:
[root@linuxprobe~]# echo `uname -a`
Linux linuxprobe.com 4.18.0-80.el8.x86_64 #1 SMP Wed Mar 13 12:02:46 UTC 2019
x86_64 x86_64 x86_64 GNU/Linux

重要的环境变量
-----------------------------------
在 Linux 系统中，变量名称一般都是大写的，
命令则都是小写的，这是一种约定俗成的规范


在用户执行了一条命令之后,命令在 Linux 中的执行分为 4 个步骤
第一步：判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），
如果是绝对路径则直接执行，否则进入第 2 步继续判断。

第二步：Linux 系统检查用户输入的命令是否为“别名命令”，
即用一个自定义的命令名称来替换原本的命令名称。

可以用 alias 命令来创建一个属于自己的命令别名
语法格式为“alias 别名=命令”
若要取消一个命令别名
则是用 unalias 命令，语法格式为“unalias 别名”。

[root@linuxprobe~]# unalias rm
[root@linuxprobe~]# rm initial-setup-ks.cfg
[root@linuxprobe~]#

第三步：：Bash 解释器判断用户输入的是内部命令还是外部命令
内部命令是解释器内部的指令，会被直接执行
绝大部分时间输入的是外部命令

使用“type 命令名称”来判断用户输入的命令是内部命令还是外部命令：
[root@linuxprobe~]# type echo
echo is a shell builtin
[root@linuxprobe~]# type uptime
uptime is /usr/bin/uptime

第四步：系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作 PATH，
可以简单地把它理解成是“解释器的小助手”，作用是告诉 Bash 解释器待执行的命令可能存
放的位置，然后 Bash 解释器就会乖乖地在这些位置中逐个查找。

[root@linuxprobe~]# echo $PATH
/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/root/bin
[root@linuxprobe~]# PATH=$PATH:/root/bin
[root@linuxprobe~]# echo $PATH
/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/root/bin:/root/bin

（.）最好不要添加到 PATH 变量中，容易被黑客利用

黑客在比较常用的公共目录/tmp 中存放了一个与 ls 或 cd 命令同名的木马文件
用户又恰巧在公共目录中执行了这些命令，那么就极有可能中招了

Linux 系统中最重要的 10 个环境变量：
-----------------------------------
HOME 用户的主目录（即家目录）
SHELL 用户在使用的 Shell 解释器名称
HISTSIZE 输出的历史命令记录条数
HISTFILESIZE 保存的历史命令记录条数

MAIL 邮件保存路径
LANG 系统语言、语系名称
RANDOM 生成一个随机数字
PS1 Bash 解释器的提示符
PATH 定义解释器搜索用户执行命令的路径
EDITOR 用户默认的文本编辑器

-----------------------------------
Vim 编辑器与 Shell 命令脚本
-----------------------------------

➢ 命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。
➢ 输入模式：正常的文本录入。
➢ 末行模式：保存或退出文档，以及设置编辑环境。

命令->输入:a,i,o等按键
命令->末行：：
返回：Esc键

命令模式中最常用的一些命令：
dd 删除（剪切）光标所在整行
5dd 删除（剪切）从光标处开始的 5 行
yy 复制光标所在整行
5yy 复制从光标处开始的 5 行
n 显示搜索命令定位到的下一个字符串
N 显示搜索命令定位到的上一个字符串
u 撤销上一步的操作
p 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面

末行模式中常用的一些命令：
:w 保存
:q 退出
:q! 强制退出（放弃对文档的修改内容）
:wq! 强制保存退出
:set nu 显示行号
:set nonu 不显示行号

:命令 执行该命令
:整数 跳转到该行
:s/one/two 将当前光标所在行的第一个 one 替换成 two
:s/one/two/g 将当前光标所在行的所有 one 替换成 two
:%s/one/two/g 将全文中的所有 one 替换成 two
?字符串 在文本中从下至上搜索该字符串
/字符串 在文本中从上至下搜索该字符串



Shell 脚本命令的工作方式有下面两种。
-----------------------------------
交互式（Interactive）：用户每输入一条命令就立即执行。
批处理（Batch）：由用户事先编写好一个完整的 Shell 脚本，Shell 会一次性执行脚本中诸多的命令。

当前系统已经默认使用 Bash 作为命令行终端解释器了：
[root@linuxprobe~]# echo $SHELL
/bin/bash

编写简单的脚本
-----------------------------------
[root@linuxprobe~]# vim example.sh
#!/bin/bash
#For Example BY linuxprobe.com
pwd
ls -al

第一行的脚本声明（#!）
第二行的注释信息（#）
第三、四行的可执行语句也就是我们平时执行的 Linux 命令了

接收用户的参数
-----------------------------------
$0 对应的是当前 Shell 脚本程序的名称
$#对应的是总共有几个参数
$*对应的是所有位置的参数值
$?对应的是显示上一次命令的执行返回值
$1、$2、$3……则分别对应着第 N 个位置的参数值


通过引用上面的变量参数来看一下真实效果：
[root@linuxprobe~]# vim example.sh
#!/bin/bash
echo "当前脚本名称为$0"
echo "总共有$#个参数，分别是$*。"
echo "第 1 个参数为$1，第 5 个为$5。"
[root@linuxprobe~]# bash example.sh one two three four five six
当前脚本名称为 example.sh
总共有 6 个参数，分别是 one two three four five six。
第 1 个参数为 one，第 5 个为 five。


判断用户的参数
-----------------------------------
Shell 脚本中的条件测试语法
成立则返回数字 0，否则便返回非零值

测试语句格式：[ 条件表达式 ]
               两边均有一个空格
➢ 文件测试语句；
➢ 逻辑测试语句；
➢ 整数值比较语句；
➢ 字符串比较语句。

文件测试所用的参数
-d 测试文件是否为目录类型
-e 测试文件是否存在
-f 判断是否为一般文件
-r 测试当前用户是否有权限读取
-w 测试当前用户是否有权限写入
-x 测试当前用户是否有权限执行

下面使用文件测试语句来判断/etc/fstab 是否为一个目录类型的文件
然后通过 Shell 解释器的内设$?变量显示上一条命令执行后的返回值
如果返回值为 0，则目录存在
如果返回值为非零的值，则意味着它不是目录，或这个目录不存在

[root@linuxprobe~]# [ -d /etc/fstab ]
[root@linuxprobe~]# echo $?
1

再使用文件测试语句来判断/etc/fstab 是否为一般文件，
如果返回值为 0，则代表文件存在，且为一般文件
[root@linuxprobe~]# [ -f /etc/fstab ]
[root@linuxprobe~]# echo $?
0

一次搞定
Shell终端中逻辑“与”的运算符号是&&
[root@linuxprobe~]# [ -e /dev/cdrom ] && echo "Exist"
Exist

逻辑“或”在 Linux 系统中的运算符号为||
[root@linuxprobe~]# echo $USER
root
[root@linuxprobe~]# [ $USER = root ] || echo "user"
[root@linuxprobe~]# su - linuxprobe
[linuxprobe@linuxprobe~]$ [ $USER = root ] || echo "user"
user

第三种逻辑语句是“非”是一个叹号(!)
[linuxprobe@linuxprobe~]$ exit
logout
[root@linuxprobe~]# [ ! $USER = root ] || echo "administrator"
administrator

➢ &&是逻辑“与”，只有当前面的语句执行成功的时候才会执行后面的语句。
➢ ||是逻辑“或”，只有当前面的语句执行失败的时候才会执行后面的语句。
➢ !是逻辑“非”，代表对逻辑测试结果取反值；之前若为正确则变成错误，
若为错误则变成正确。

可用的整数比较运算符:
-eq 是否等于
-ne 是否不等于
-gt 是否大于
-lt 是否小于
-le 是否等于或小于
-ge 是否大于或等于

10 是否大于 10 以及 10 是否等于 10:
[root@linuxprobe~]# [ 10 -gt 10 ]
[root@linuxprobe~]# echo $?
1
[root@linuxprobe~]# [ 10 -eq 10 ]
[root@linuxprobe~]# echo $?
0

 free -m 命令查看内存使用量情况（单位为 MB）
 通过“grep Mem:”命令过滤出剩余内存量的行
 再用 awk '{print $4}'命令只保留第 4 列
 
[root@linuxprobe~]# free -m
total used free shared buff/cache available
Mem: 1966 1374 128 16 463 397
Swap: 2047 66 1981
[root@linuxprobe~]# free -m | grep Mem:
Mem: 1966 1374 128 16 463 397
[root@linuxprobe~]# free -m | grep Mem: | awk '{print $4}'
128

如果想把这个命令写入到 Shell 脚本中，
那么建议把输出结果赋值给一个变量，以方便其他命令进行调用：

[root@linuxprobe~]# FreeMem=`free -m | grep Mem: | awk '{print $4}'`
[root@linuxprobe~]# echo $FreeMem
128

字符串比较
-----------------------------------
= 比较字符串内容是否相同
!= 比较字符串内容是否不同
-z 判断字符串内容是否为空

接下来通过判断 String 变量是否为空值:
[root@linuxprobe~]# [ -z $String ]
[root@linuxprobe~]# echo $?
0

流程控制语句
-----------------------------------
if、for、while、case 这 4 种流程控制语句

if 条件测试语句
-----------------------------------
分支结构由 if、then、fi关键词组成

[root@linuxprobe~]# vim mkcdrom.sh
#!/bin/bash
DIR="/media/cdrom"
if [ ! -d $DIR ]
then
mkdir -p $DIR
fi

if、then、else、fi 关键词组成

[root@linuxprobe~]# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null
if [ $? -eq 0 ]
then
echo "Host $1 is On-line."
else
echo "Host $1 is Off-line."
fi

下面使用双分支的 if 条件语句来验证某台主机是否在线
-c 参数来规定尝试的次数
-i 参数定义每个数据包的发送间隔
-W 参数定义等待超时时间

[root@linuxprobe~]# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null
if [ $? -eq 0 ]
then
echo "Host $1 is On-line."
else
echo "Host $1 is Off-line."
fi

[root@linuxprobe~]# bash chkhost.sh 192.168.10.10
Host 192.168.10.10 is On-line.
[root@linuxprobe~]# bash chkhost.sh 192.168.10.20
Host 192.168.10.20 is Off-line.

多分支结构由 if、then、else、elif、fi 关键词组成
-----------------------------------